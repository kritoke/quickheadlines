<!DOCTYPE HTML>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>QuickHeadlines</title>
  <style>
    * { box-sizing: border-box; }
    html, body { 
      padding: 0; 
      margin: 0; 
      overflow-x: hidden; 
      width: 100%;
      max-width: 100vw;
    }
    #elm { 
      width: 100%; 
      max-width: 100vw;
      overflow-x: hidden;
    }
  </style>
  <link rel="stylesheet" href="/public/timeline.css">
</head>
<body>
  <div id="elm"></div>
  <script src="/elm.js"></script>
  <script>
    try {
      var app = Elm.Main.init({
        node: document.getElementById('elm'),
        flags: {
          width: window.innerWidth,
          height: window.innerHeight,
          prefersDark: window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches,
          timestamp: Math.floor(Date.now() / 1000)
        }
      });
    } catch (e) {
      console.error('Elm initialization failed:', e);
    }
  </script>
  <script>
    // Attach scroll observers to feed bodies to toggle `.is-at-bottom` which
    // controls the bottom shadow indicating more content. Also watch for
    // dynamically added feed boxes so behavior works after Elm updates.
    (function () {
      function isAtBottom(el) {
        return Math.abs(el.scrollHeight - el.scrollTop - el.clientHeight) <= 1;
      }

      function updateFeedBoxClass(feedBox) {
          try {
           var body = feedBox.querySelector('[data-semantic="feed-body"]') || feedBox.querySelector('.feed-body');
          if (!body) {
            // fallback: try to find a scrollable descendant
            body = findScrollableDescendant(feedBox);
          }
          if (!body) return;
          if (isAtBottom(body)) feedBox.classList.add('is-at-bottom'); else feedBox.classList.remove('is-at-bottom');
        } catch (e) { /* ignore */ }
      }

       function setupScrollForFeedBox(feedBox) {
         var body = feedBox.querySelector('[data-semantic="feed-body"]') || feedBox.querySelector('.feed-body');
        if (!body) {
          body = findScrollableDescendant(feedBox);
        }
        if (!body) return;
        // initial state
        updateFeedBoxClass(feedBox);
        // remove previous listener marker
        if (body.__qh_scroll_attached) return;
        body.__qh_scroll_attached = true;
        body.addEventListener('scroll', function () { updateFeedBoxClass(feedBox); }, { passive: true });
        // also update on resize (content height may change)
        var ro = new ResizeObserver(function () { updateFeedBoxClass(feedBox); });
        ro.observe(body);
      }

      // Heuristic: find a descendant element that is scrollable (overflow-y auto/scroll or has scrollHeight>clientHeight)
      function findScrollableDescendant(el) {
        try {
          var candidates = el.querySelectorAll('*');
          for (var i = 0; i < candidates.length; i++) {
            var c = candidates[i];
            var style = window.getComputedStyle(c);
            if (style && (style.overflowY === 'auto' || style.overflowY === 'scroll')) return c;
            if (c.scrollHeight - c.clientHeight > 10) return c;
          }
        } catch (e) { /* ignore */ }
        return null;
      }

       function scanAndAttach() {
         // Prefer semantic attribute selector, fall back to legacy class
         var nodes = document.querySelectorAll('[data-semantic="feed-card"]');
         if (!nodes.length) nodes = document.querySelectorAll('.feed-box');
         nodes.forEach(setupScrollForFeedBox);
       }

      // Watch for feed-box additions/removals
      var mo = new MutationObserver(function () { scanAndAttach(); });
      mo.observe(document.documentElement || document.body, { childList: true, subtree: true });

      // Run initial attach after a short delay (Elm may finish rendering)
      document.addEventListener('DOMContentLoaded', function () { setTimeout(scanAndAttach, 50); });
      // Also run at intervals briefly to catch late renders
      var _count = 0; var _int = setInterval(function () { scanAndAttach(); _count++; if (_count > 20) clearInterval(_int); }, 250);
    })();

    // Debug panel: visible when ?debug=true is in the URL. Non-destructive helper to
    // inspect feed-card counts, inserted animations, and ::after background.
    (function () {
      function makeDebugPanel() {
        var panel = document.createElement('div');
        panel.id = 'qh-debug-panel';
        panel.style.position = 'fixed';
        panel.style.left = '12px';
        panel.style.bottom = '12px';
        panel.style.zIndex = '99999';
        panel.style.background = 'rgba(0,0,0,0.75)';
        panel.style.color = 'white';
        panel.style.padding = '8px 10px';
        panel.style.borderRadius = '8px';
        panel.style.fontSize = '12px';
        panel.style.fontFamily = 'system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
        panel.style.maxWidth = '320px';
        panel.style.boxShadow = '0 8px 30px rgba(2,6,23,0.5)';

        var title = document.createElement('div');
        title.textContent = 'QuickHeadlines Debug';
        title.style.fontWeight = '600';
        title.style.marginBottom = '6px';
        panel.appendChild(title);

        var content = document.createElement('pre');
        content.id = 'qh-debug-content';
        content.style.whiteSpace = 'pre-wrap';
        content.style.margin = '0';
        content.style.maxHeight = '260px';
        content.style.overflow = 'auto';
        content.textContent = 'Initializing...';
        panel.appendChild(content);

        var btnRow = document.createElement('div');
        btnRow.style.display = 'flex';
        btnRow.style.gap = '6px';
        btnRow.style.marginTop = '8px';

        var copyBtn = document.createElement('button');
        copyBtn.textContent = 'Copy';
        copyBtn.style.flex = '1';
        copyBtn.style.padding = '6px';
        copyBtn.style.borderRadius = '6px';
        copyBtn.style.border = 'none';
        copyBtn.style.cursor = 'pointer';
        copyBtn.onclick = function () {
          navigator.clipboard && navigator.clipboard.writeText(content.textContent || '');
        };
        btnRow.appendChild(copyBtn);

        var closeBtn = document.createElement('button');
        closeBtn.textContent = 'Hide';
        closeBtn.style.flex = '1';
        closeBtn.style.padding = '6px';
        closeBtn.style.borderRadius = '6px';
        closeBtn.style.border = 'none';
        closeBtn.style.cursor = 'pointer';
        closeBtn.onclick = function () { panel.style.display = 'none'; };
        btnRow.appendChild(closeBtn);

        panel.appendChild(btnRow);
        document.body.appendChild(panel);
        return { panel: panel, content: content };
      }

      function readDiagnostics() {
        var card = document.querySelector('[data-semantic="feed-card"]') || document.querySelector('.feed-box');
        var cards = document.querySelectorAll('[data-semantic="feed-card"]');
        if (!cards.length) cards = document.querySelectorAll('.feed-box');
        var feedBody = card ? (card.querySelector('[data-semantic="feed-body"]') || card.querySelector('.feed-body')) : null;

        function pseudoProp(el, pseudo, prop) {
          try { if (!el) return null; return window.getComputedStyle(el, pseudo).getPropertyValue(prop) || null; } catch (e) { return null; }
        }

        var afterBg = pseudoProp(card, '::after', 'background-image') || pseudoProp(card, '::after', 'background');

        var inserted = Array.from(document.querySelectorAll('.timeline-inserted'));
        var insertedSample = inserted.slice(0,5).map(function (el) { return { tag: el.tagName, classes: el.className }; });

        var anims = inserted.map(function (el) {
          try { return window.getComputedStyle(el as any).getPropertyValue('animation-name'); } catch (e) { return null; }
        });

        var isAtBottomCount = 0;
        cards.forEach(function (c) { if (c.classList && c.classList.contains('is-at-bottom')) isAtBottomCount++; });

        return {
          timestamp: new Date().toLocaleTimeString(),
          cards: cards.length,
          hasFeedBody: !!feedBody,
          insertedCount: inserted.length,
          insertedSample: insertedSample,
          animationNames: anims.filter(Boolean).slice(0,5),
          afterBg: afterBg,
          isAtBottomCount: isAtBottomCount
        };
      }

      function renderDiagnostics(contentEl, obj) {
        contentEl.textContent = JSON.stringify(obj, null, 2);
      }

      if (location.search.indexOf('debug=true') !== -1) {
        var dbg = makeDebugPanel();
        function tick() { var d = readDiagnostics(); renderDiagnostics(dbg.content, d); }
        tick();
        var dbgInterval = setInterval(tick, 700);
      }
    })();
  </script>
</body>
</html>
