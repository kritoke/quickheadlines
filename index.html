<!DOCTYPE HTML>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>QuickHeadlines</title>
  <style>
    * { box-sizing: border-box; }
    html, body { 
      padding: 0; 
      margin: 0; 
      overflow-x: hidden; 
      width: 100%;
      max-width: 100vw;
    }
    #elm { 
      width: 100%; 
      max-width: 100vw;
      overflow-x: hidden;
    }
  </style>
  <link rel="stylesheet" href="/public/timeline.css">
</head>
<body>
  <div id="elm"></div>
  <script src="/elm.js"></script>
  <script>
    try {
      var app = Elm.Main.init({
        node: document.getElementById('elm'),
        flags: {
          width: window.innerWidth,
          height: window.innerHeight,
          prefersDark: window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches,
          timestamp: Math.floor(Date.now() / 1000)
        }
      });
    } catch (e) {
      console.error('Elm initialization failed:', e);
    }
  </script>
  <script>
    // Attach scroll observers to feed bodies to toggle `.is-at-bottom` which
    // controls the bottom shadow indicating more content. Also watch for
    // dynamically added feed boxes so behavior works after Elm updates.
    (function () {
      function isAtBottom(el) {
        return Math.abs(el.scrollHeight - el.scrollTop - el.clientHeight) <= 1;
      }

      function updateFeedBoxClass(feedBox) {
        try {
          var body = feedBox.querySelector('.feed-body');
          if (!body) {
            // fallback: try to find a scrollable descendant
            body = findScrollableDescendant(feedBox);
          }
          if (!body) return;
          if (isAtBottom(body)) feedBox.classList.add('is-at-bottom'); else feedBox.classList.remove('is-at-bottom');
        } catch (e) { /* ignore */ }
      }

      function setupScrollForFeedBox(feedBox) {
        var body = feedBox.querySelector('.feed-body');
        if (!body) {
          body = findScrollableDescendant(feedBox);
        }
        if (!body) return;
        // initial state
        updateFeedBoxClass(feedBox);
        // remove previous listener marker
        if (body.__qh_scroll_attached) return;
        body.__qh_scroll_attached = true;
        body.addEventListener('scroll', function () { updateFeedBoxClass(feedBox); }, { passive: true });
        // also update on resize (content height may change)
        var ro = new ResizeObserver(function () { updateFeedBoxClass(feedBox); });
        ro.observe(body);
      }

      // Heuristic: find a descendant element that is scrollable (overflow-y auto/scroll or has scrollHeight>clientHeight)
      function findScrollableDescendant(el) {
        try {
          var candidates = el.querySelectorAll('*');
          for (var i = 0; i < candidates.length; i++) {
            var c = candidates[i];
            var style = window.getComputedStyle(c);
            if (style && (style.overflowY === 'auto' || style.overflowY === 'scroll')) return c;
            if (c.scrollHeight - c.clientHeight > 10) return c;
          }
        } catch (e) { /* ignore */ }
        return null;
      }

      function scanAndAttach() {
        document.querySelectorAll('.feed-box').forEach(setupScrollForFeedBox);
      }

      // Watch for feed-box additions/removals
      var mo = new MutationObserver(function () { scanAndAttach(); });
      mo.observe(document.documentElement || document.body, { childList: true, subtree: true });

      // Run initial attach after a short delay (Elm may finish rendering)
      document.addEventListener('DOMContentLoaded', function () { setTimeout(scanAndAttach, 50); });
      // Also run at intervals briefly to catch late renders
      var _count = 0; var _int = setInterval(function () { scanAndAttach(); _count++; if (_count > 20) clearInterval(_int); }, 250);
    })();
  </script>
</body>
</html>
