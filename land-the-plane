#!/bin/bash
# land-the-plane - Unified "Land the Plane" production release checklist
# Auto-detects language and runs appropriate checks
# Usage: ./land-the-plane [language] [--non-dev]
#   language: crystal | elixir | gleam | elm | nim | go | node (auto-detected if not specified)
#   --non-dev: Run in non-dev mode (skip dev-specific checks like tests for Elm)

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Configuration
SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
PROJECT_DIR="$(pwd)"
LOG_FILE="land-the-plane.log"
NON_DEV_MODE=""

# Language detection function
detect_language() {
    if [ -n "$1" ]; then
        echo "$1"
        return
    fi
    
    if [ -f "shard.yml" ]; then
        echo "crystal"
        return
    fi
    if [ -f "mix.exs" ]; then
        echo "elixir"
        return
    fi
    if [ -f "gleam.toml" ]; then
        echo "gleam"
        return
    fi
    if [ -f "elm.json" ]; then
        echo "elm"
        return
    fi
    if ls *.nimble &>/dev/null 2>&1; then
        echo "nim"
        return
    fi
    if [ -f "go.mod" ] || [ -f "go.sum" ]; then
        echo "go"
        return
    fi
    if [ -f "package.json" ]; then
        echo "node"
        return
    fi
    
    echo "unknown"
}

# Get configuration value
get_config() {
    local lang="$1"
    local key="$2"
    
    case "$lang" in
        crystal)
            case "$key" in
                format_cmd) echo "crystal tool format --check" ;;
                lint_cmd) echo "ameba --format progress" ;;
                security_cmd) echo "manual" ;;
                build_cmd) echo "crystal build --release src/main.cr -o /tmp/crystal_release_build" ;;
                test_cmd) echo "crystal spec --no-color" ;;
                cleanup_artifacts) echo "*.log spec_out.txt *.cr.bak *.dwarf .crystal/ bin/" ;;
                verify_artifacts) echo "*.log spec_out.txt *.dwarf *.cr.bak .crystal/ bin/" ;;
            esac
            ;;
        elixir)
            case "$key" in
                format_cmd) echo "mix format --check-formatted" ;;
                lint_cmd) echo "mix credo --strict" ;;
                security_cmd) echo "mix sobelow --exit High" ;;
                build_cmd) echo "MIX_ENV=prod mix release" ;;
                test_cmd) echo "mix test --no-color" ;;
                cleanup_artifacts) echo "*.log erl_crash.dump *.beam *.ex.bak _build/dev/ deps/" ;;
                verify_artifacts) echo "*.log erl_crash.dump *.beam *.ex.bak _build/dev/" ;;
            esac
            ;;
        gleam)
            case "$key" in
                format_cmd) echo "gleam format --check" ;;
                lint_cmd) echo "none" ;;
                security_cmd) echo "manual" ;;
                build_cmd) echo "gleam build --target javascript" ;;
                test_cmd) echo "gleam test" ;;
                cleanup_artifacts) echo "*.log erl_crash.dump *.beam *.gleam.bak build/dev/" ;;
                verify_artifacts) echo "*.log erl_crash.dump *.beam *.gleam.bak build/dev/" ;;
            esac
            ;;
        elm)
            case "$key" in
                format_cmd) echo "elm-format src/ --yes" ;;
                lint_cmd) echo "none" ;;
                security_cmd) echo "manual" ;;
                build_cmd) echo "elm make src/Main.elm --output=elm.js --optimize" ;;
                test_cmd) echo "elm-test" ;;
                cleanup_artifacts) echo "*.log *.elm.bak elm-stuff/" ;;
                verify_artifacts) echo "*.log *.elm.bak elm-stuff/" ;;
            esac
            ;;
        nim)
            case "$key" in
                format_cmd) echo "nim pretty --check" ;;
                lint_cmd) echo "nim check --hints:off --verbosity:2" ;;
                security_cmd) echo "manual" ;;
                build_cmd) echo "nim c -d:release src/main.nim -o /tmp/nim_release_build" ;;
                test_cmd) echo "nimble test" ;;
                cleanup_artifacts) echo "*.log erl_crash.dump *.beam *.nim.bak build/ nimcache/" ;;
                verify_artifacts) echo "*.log erl_crash.dump *.beam *.nim.bak nimcache/" ;;
            esac
            ;;
        go)
            case "$key" in
                format_cmd) echo "gofmt -l ." ;;
                lint_cmd) echo "go vet ./..." ;;
                security_cmd) echo "go mod tidy && go list -json -m all | nancy sleuth" ;;
                build_cmd) echo "go build -o /tmp/go_release_build" ;;
                test_cmd) echo "go test ./..." ;;
                cleanup_artifacts) echo "*.log *.test *.out go.sum" ;;
                verify_artifacts) echo "*.log *.test *.out" ;;
            esac
            ;;
        node)
            case "$key" in
                format_cmd) echo "npm run format 2>/dev/null || npx prettier --check . 2>/dev/null || echo 'none'" ;;
                lint_cmd) echo "npm run lint 2>/dev/null || npx eslint . 2>/dev/null || echo 'none'" ;;
                security_cmd) echo "npm audit --audit-level=moderate 2>/dev/null || echo 'none'" ;;
                build_cmd) echo "npm run build 2>/dev/null || echo 'none'" ;;
                test_cmd) echo "npm test" ;;
                cleanup_artifacts) echo "*.log node_modules/ .next/ dist/ build/ .cache/" ;;
                verify_artifacts) echo "*.log node_modules/ .next/ dist/ build/" ;;
            esac
            ;;
    esac
}

# Logging functions
log_info() {
    echo -e "${BLUE}[INFO]${NC} $1" | tee -a "$LOG_FILE"
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1" | tee -a "$LOG_FILE"
}

log_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1" | tee -a "$LOG_FILE"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1" | tee -a "$LOG_FILE"
}

# Phase 1: Cleanup
phase_cleanup() {
    local lang="$1"
    log_info "Phase 1: Cleanup - Removing debug artifacts and temporary files"
    
    local artifacts=$(get_config "$lang" "cleanup_artifacts")
    
    for pattern in $artifacts; do
        if [[ "$pattern" == */ ]]; then
            # Directory
            local dir="${pattern%/}"
            if [ -d "$dir" ]; then
                rm -rf "$dir"
                log_info "Removed: $dir/"
            fi
        else
            # File pattern
            find . -name "$pattern" -type f -delete 2>/dev/null || true
            log_info "Removed: $pattern"
        fi
    done
    
    log_success "Cleanup completed"
}

# Phase 2: Format Verification
phase_format() {
    local lang="$1"
    log_info "Phase 2: Format Verification - Checking code formatting"
    
    local cmd=$(get_config "$lang" "format_cmd")
    
    if [ "$cmd" = "none" ]; then
        log_success "No format check required for this language"
        return 0
    fi
    
    # Extract command name
    local cmd_name=$(echo "$cmd" | awk '{print $1}')
    
    if ! command -v "$cmd_name" &> /dev/null; then
        log_warning "$cmd_name not found. Skipping format check."
        return 0
    fi
    
    # Special handling for elm-format (no --validate option)
    if [ "$lang" = "elm" ]; then
        # Check if git is available
        if ! command -v "git" &> /dev/null; then
            log_warning "git not found. Cannot check elm-format changes."
            return 0
        fi
        
        # Create temp copy of git status
        local git_status=$(git status --porcelain 2>/dev/null || true)
        
        # Run elm-format
        if ! eval "$cmd" > /dev/null 2>&1; then
            log_error "elm-format failed to run"
            eval "$cmd" 2>&1 | tee -a "$LOG_FILE"
            return 1
        fi
        
        # Check if files were modified
        local new_git_status=$(git status --porcelain 2>/dev/null || true)
        
        if [ "$git_status" != "$new_git_status" ]; then
            log_error "Code formatting issues found. Run 'elm-format src/ --yes' to fix."
            git diff --name-only 2>/dev/null | head -5 | tee -a "$LOG_FILE"
            # Revert changes
            git checkout -- src/ 2>/dev/null || true
            return 1
        fi
        
        log_success "Code is properly formatted"
        return 0
    fi
    
    # Original logic for other languages
    if ! eval "$cmd" > /dev/null 2>&1; then
        log_error "Code formatting issues found. Run format command to fix."
        eval "$cmd" 2>&1 | tee -a "$LOG_FILE"
        return 1
    fi
    
    log_success "Code is properly formatted"
}

# Phase 3: Lint Verification
phase_lint() {
    local lang="$1"
    log_info "Phase 3: Lint Verification - Running language-specific linters"
    
    local cmd=$(get_config "$lang" "lint_cmd")
    
    if [ "$cmd" = "none" ]; then
        log_success "No separate linter required for this language"
        return 0
    fi
    
    # Extract command name
    local cmd_name=$(echo "$cmd" | awk '{print $1}')
    
    if ! command -v "$cmd_name" &> /dev/null; then
        log_warning "$cmd_name not found. Skipping lint check."
        return 0
    fi
    
    if ! eval "$cmd" > /dev/null 2>&1; then
        log_error "Linting issues found. Run lint command to see details."
        eval "$cmd" 2>&1 | tee -a "$LOG_FILE"
        return 1
    fi
    
    log_success "No linting issues found"
}

# Phase 4: Security Audit
phase_security() {
    local lang="$1"
    log_info "Phase 4: Security Audit - Running security scanners"
    
    local cmd=$(get_config "$lang" "security_cmd")
    
    if [ "$cmd" = "none" ]; then
        log_success "No security audit required for this language"
        return 0
    fi
    
    if [ "$cmd" = "manual" ]; then
        # Manual security checks
        log_info "Performing manual security checks..."
        
        # Check for unsafe blocks (Crystal)
        if [ "$lang" = "crystal" ]; then
            local unsafe_files=$(find src -name "*.cr" -exec grep -l "unsafe" {} \; 2>/dev/null || true)
            if [ -n "$unsafe_files" ]; then
                log_warning "Found 'unsafe' blocks in the following files:"
                echo "$unsafe_files" | tee -a "$LOG_FILE"
                log_warning "Please verify these are documented and necessary per CRYSTAL_SECURITY.md"
            else
                log_success "No unsafe blocks found"
            fi
        fi
        
        # Check for unsafe/ptr blocks (Nim)
        if [ "$lang" = "nim" ]; then
            local unsafe_files=$(find src -name "*.nim" -exec grep -l "unsafe" {} \; 2>/dev/null || true)
            if [ -n "$unsafe_files" ]; then
                log_warning "Found 'unsafe' blocks in the following files:"
                echo "$unsafe_files" | tee -a "$LOG_FILE"
                log_warning "Please verify these are documented and necessary per NIM_SECURITY.md"
            else
                log_success "No unsafe blocks found"
            fi
            
            local ptr_files=$(find src -name "*.nim" -exec grep -lE "\bptr\b" {} \; 2>/dev/null || true)
            if [ -n "$ptr_files" ]; then
                log_warning "Found 'ptr' usage in the following files:"
                echo "$ptr_files" | tee -a "$LOG_FILE"
                log_warning "Please verify these are documented and necessary per NIM_SECURITY.md"
            else
                log_success "No ptr usage found"
            fi
        fi
        
        # Check for hardcoded secrets (all languages)
        # Look for actual string literals being assigned, not variable references
        local secret_patterns=(
            "password\s*=\s*\"[^\"]"
            "api_key\s*=\s*\"[^\"]"
            "secret\s*=\s*\"[^\"]"
            "token\s*=\s*\"[^\"]"
        )
        
        local found_secrets=0
        for pattern in "${secret_patterns[@]}"; do
            local src_dir="src"
            [ "$lang" = "elixir" ] && src_dir="lib"
            
            if grep -rE "$pattern" "$src_dir/" --include="*.cr" --include="*.ex" --include="*.gleam" --include="*.elm" 2>/dev/null | grep -v "ENV\[" | grep -v "env.config" | grep -v "auth\." | grep -q .; then
                log_error "Potential hardcoded secret found matching: $pattern"
                grep -rE "$pattern" "$src_dir/" --include="*.cr" --include="*.ex" --include="*.gleam" --include="*.elm" 2>/dev/null | grep -v "ENV\[" | grep -v "env.config" | grep -v "auth\." | head -5 | tee -a "$LOG_FILE"
                found_secrets=1
            fi
        done
        
        if [ $found_secrets -eq 0 ]; then
            log_success "No hardcoded secrets detected"
        else
            log_error "Hardcoded secrets found. Please use environment variables."
            return 1
        fi
        
        return 0
    fi
    
    # Extract command name
    local cmd_name=$(echo "$cmd" | awk '{print $1}')
    
    if ! command -v "$cmd_name" &> /dev/null; then
        log_warning "$cmd_name not found. Skipping security audit."
        return 0
    fi
    
    if ! eval "$cmd" > /dev/null 2>&1; then
        log_error "Security issues found. Run security command to see details."
        eval "$cmd" 2>&1 | tee -a "$LOG_FILE"
        return 1
    fi
    
    log_success "No security issues found"
}

# Phase 5: Production Build
phase_build() {
    local lang="$1"
    log_info "Phase 5: Production Build - Building in release mode"
    
    local cmd=$(get_config "$lang" "build_cmd")
    
    # Extract command name
    local cmd_name=$(echo "$cmd" | awk '{print $1}')
    
    if ! command -v "$cmd_name" &> /dev/null; then
        log_warning "$cmd_name not found. Skipping build phase."
        return 0
    fi
    
    # Find main entry point for Crystal
    if [ "$lang" = "crystal" ]; then
        local main_file=""
        
        # Try to extract main file from shard.yml
        if [ -f "shard.yml" ]; then
            # Look for targets section and extract main file
            main_file=$(grep -A 10 "^targets:" shard.yml 2>/dev/null | grep "main:" | head -1 | sed 's/.*main: *//' | tr -d ' ')
        fi
        
        # Fall back to common defaults if not found in shard.yml
        if [ -z "$main_file" ] || [ ! -f "$main_file" ]; then
            main_file="src/main.cr"
            if [ ! -f "$main_file" ]; then
                main_file="src/app.cr"
            fi
        fi
        
        if [ ! -f "$main_file" ]; then
            log_warning "Could not find main entry point (tried shard.yml targets and common defaults). Skipping build phase."
            return 0
        fi
        
        cmd="crystal build --release $main_file -o /tmp/crystal_release_build"
    fi
    
    # Find main entry point for Elm
    if [ "$lang" = "elm" ]; then
        local main_file="src/Main.elm"
        if [ ! -f "$main_file" ]; then
            log_warning "Could not find main entry point (expected src/Main.elm). Skipping build phase."
            return 0
        fi
        
        cmd="elm make $main_file --output=elm.js --optimize"
    fi
    
    # Find main entry point for Nim
    if [ "$lang" = "nim" ]; then
        local main_file="src/main.nim"
        if [ ! -f "$main_file" ]; then
            # Try to find .nimble file and extract package name
            local nimble_file=$(ls *.nimble 2>/dev/null | head -1)
            if [ -n "$nimble_file" ]; then
                local pkg_name=$(grep -E "^package" "$nimble_file" | head -1 | awk '{print $2}')
                if [ -n "$pkg_name" ]; then
                    main_file="src/${pkg_name}.nim"
                fi
            fi
        fi
        
        if [ ! -f "$main_file" ]; then
            log_warning "Could not find main entry point (expected src/main.nim or src/<package>.nim). Skipping build phase."
            return 0
        fi
        
        cmd="nim c -d:release $main_file -o /tmp/nim_release_build"
    fi
    
    log_info "Building (this may take a while)..."
    
    if ! eval "$cmd" 2>&1 | tee -a "$LOG_FILE"; then
        log_error "Build failed"
        return 1
    fi
    
    # Check for warnings in build output
    if grep -i "warning:" "$LOG_FILE" > /dev/null 2>&1; then
        log_error "Build contains warnings. Please fix before release."
        grep -i "warning:" "$LOG_FILE" | tee -a "$LOG_FILE"
        return 1
    fi
    
    # Check for deprecation warnings
    if grep -i "deprecated:" "$LOG_FILE" > /dev/null 2>&1; then
        log_error "Build contains deprecation warnings. Please fix before release."
        grep -i "deprecated:" "$LOG_FILE" | tee -a "$LOG_FILE"
        return 1
    fi
    
    log_success "Production build completed successfully"
}

# Phase 6: Test Verification
phase_test() {
    local lang="$1"
    log_info "Phase 6: Test Verification - Running full test suite"
    
    # In non-dev mode for Elm, skip tests (tests are dev-only)
    if [ "$lang" = "elm" ] && [ "$NON_DEV_MODE" = "true" ]; then
        log_info "Non-dev mode: Skipping tests for Elm project"
        log_info "Tests should have been run during development"
        return 0
    fi
    
    local cmd=$(get_config "$lang" "test_cmd")
    
    # Check if test directory exists
    local test_dir="test"
    [ "$lang" = "crystal" ] && test_dir="spec"
    [ "$lang" = "nim" ] && test_dir="tests"
    
    if [ ! -d "$test_dir" ]; then
        log_warning "No $test_dir directory found. Skipping tests."
        return 0
    fi
    
    # Extract command name
    local cmd_name=$(echo "$cmd" | awk '{print $1}')
    
    if ! command -v "$cmd_name" &> /dev/null; then
        log_warning "$cmd_name not found. Skipping tests."
        return 0
    fi
    
    log_info "Running tests (this may take a while)..."
    
    if ! eval "$cmd" 2>&1 | tee -a "$LOG_FILE"; then
        log_error "Tests failed"
        return 1
    fi
    
    log_success "All tests passed"
}

# Phase 7: Artifact Verification
phase_verify() {
    local lang="$1"
    log_info "Phase 7: Artifact Verification - Checking for remaining debug artifacts"
    
    local found_issues=0
    local artifacts=$(get_config "$lang" "verify_artifacts")
    
    for pattern in $artifacts; do
        if [[ "$pattern" == */ ]]; then
            # Directory
            local dir="${pattern%/}"
            if [ -d "$dir" ]; then
                log_error "Found directory: $dir/"
                found_issues=1
            fi
        else
            # File pattern
            if find . -name "$pattern" -type f -not -name "$LOG_FILE" 2>/dev/null | grep -q .; then
                log_error "Found debug artifact: $pattern"
                find . -name "$pattern" -type f -not -name "$LOG_FILE" 2>/dev/null | head -5 | tee -a "$LOG_FILE"
                found_issues=1
            fi
        fi
    done
    
    # Additional language-specific checks
    if [ "$lang" = "elixir" ]; then
        # Check for .beam files in lib/
        if find lib/ -name "*.beam" -type f 2>/dev/null | grep -q .; then
            log_error "Found .beam files in lib/ directory"
            find lib/ -name "*.beam" -type f 2>/dev/null | head -5 | tee -a "$LOG_FILE"
            found_issues=1
        fi
    fi
    
    if [ "$lang" = "gleam" ]; then
        # Check for .beam files in src/
        if find src/ -name "*.beam" -type f 2>/dev/null | grep -q .; then
            log_error "Found .beam files in src/ directory"
            find src/ -name "*.beam" -type f 2>/dev/null | head -5 | tee -a "$LOG_FILE"
            found_issues=1
        fi
    fi
    
    if [ "$lang" = "nim" ]; then
        # Check for .nim.bak files in src/
        if find src/ -name "*.nim.bak" -type f 2>/dev/null | grep -q .; then
            log_error "Found .nim.bak files in src/ directory"
            find src/ -name "*.nim.bak" -type f 2>/dev/null | head -5 | tee -a "$LOG_FILE"
            found_issues=1
        fi
        # Check for nimcache directory
        if [ -d "nimcache" ]; then
            log_error "Found nimcache directory - should be cleaned up"
            found_issues=1
        fi
    fi
    
    # Elm non-dev mode specific checks
    if [ "$lang" = "elm" ] && [ "$NON_DEV_MODE" = "true" ]; then
        # Check that elm.js was generated in non-dev mode
        if [ -f "elm.js" ]; then
            local js_size=$(stat -f%z "elm.js" 2>/dev/null || stat -c%s "elm.js" 2>/dev/null || echo "0")
            local js_size_num=$(echo "$js_size" | grep -E '^[0-9]+$' || echo "0")
            if [ "$js_size_num" -gt 0 ]; then
                log_success "Production elm.js generated ($js_size bytes)"
            else
                log_warning "elm.js exists but size could not be determined"
            fi
        else
            log_error "elm.js not found - build may have failed"
            found_issues=1
        fi
        
        # Check for source maps (should not exist in production)
        if find . -name "*.js.map" -type f 2>/dev/null | grep -q .; then
            log_warning "Source maps found (.js.map files) - consider removing for production"
        fi
    fi
    
    if [ $found_issues -eq 0 ]; then
        log_success "No debug artifacts found"
    else
        log_error "Debug artifacts still present"
        return 1
    fi
}

# Main execution
main() {
    local language=$(detect_language "$1")
    local non_dev_mode=false
    
    # Check for --non-dev flag in arguments
    if [ $# -gt 0 ]; then
        # If we specified a language explicitly, shift to next arg
        if [ "$language" != "$(detect_language)" ]; then
            shift
        fi
        
        while [[ $# -gt 0 ]]; do
            case "$1" in
                --non-dev)
                    non_dev_mode=true
                    shift
                    ;;
                *)
                    shift
                    ;;
            esac
        done
    fi
    
    # Store non-dev mode in a global variable for phase functions
    NON_DEV_MODE="$non_dev_mode"
    
    echo "=========================================="
    echo "ðŸ›¬ Land the Plane - Production Release Checklist"
    echo "=========================================="
    echo "Language: $language"
    echo "Project: $PROJECT_DIR"
    if [ "$NON_DEV_MODE" = "true" ]; then
        echo "Mode: NON-DEV (Production) - Skipping dev-specific checks"
    else
        echo "Mode: DEV (Full checks)"
    fi
    echo "=========================================="
    echo ""
    
    if [ "$language" = "unknown" ]; then
        echo -e "${RED}ERROR: Could not detect project language${NC}"
        echo ""
        echo "Please specify language explicitly:"
        echo "  ./land-the-plane crystal"
        echo "  ./land-the-plane elixir"
        echo "  ./land-the-plane gleam"
        echo "  ./land-the-plane elm"
        echo "  ./land-the-plane nim"
        echo "  ./land-the-plane go"
        echo "  ./land-the-plane node"
        echo ""
        echo "Or ensure your project has one of these files:"
        echo "  - shard.yml (Crystal)"
        echo "  - mix.exs (Elixir)"
        echo "  - gleam.toml (Gleam)"
        echo "  - elm.json (Elm)"
        echo "  - *.nimble (Nim)"
        echo "  - go.mod or go.sum (Go)"
        echo "  - package.json (Node/npm)"
        exit 1
    fi
    
    # Initialize log file
    echo "Land the Plane - $language - $(date)" > "$LOG_FILE"
    
    # Run phases
    phase_cleanup "$language" || exit 1
    phase_format "$language" || exit 1
    phase_lint "$language" || exit 1
    phase_security "$language" || exit 1
    phase_build "$language" || exit 1
    phase_test "$language" || exit 1
    phase_verify "$language" || exit 1
    
    echo ""
    echo "=========================================="
    log_success "âœ… All checks passed! Ready for production release."
    echo "=========================================="
    echo ""
    echo "Next steps:"
    echo "  1. Review log: cat $LOG_FILE"
    echo "  2. Create a git tag: git tag -a v1.0.0 -m 'Release v1.0.0'"
    echo "  3. Push tag: git push origin v1.0.0"
}

# Run main function
main "$@"
