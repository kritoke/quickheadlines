<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>QuickHeadlines</title>
  <style>
    * { box-sizing: border-box; }
    body { margin: 0; padding: 0; background: #121212; }
    #app { width: 100vw; min-height: 100vh; background: #121212; }
    .feed-header { transition: background-color 0.3s ease, color 0.3s ease; }
    [data-timeline-header="true"] {
      background-color: transparent !important;
      background: transparent !important;
      font-size: 1.25rem !important; /* 20px equivalent */
      font-weight: bold;
      -webkit-text-size-adjust: none;
    }
    [data-timeline-page="true"] [data-adaptive]:not(.feed-header) {
      background-color: transparent !important;
      background: transparent !important;
      color: inherit !important;
    }
    [data-timeline-page="true"] [data-adaptive]:not(.feed-header) a {
      color: inherit !important;
      text-decoration: underline !important;
    }
    [data-timeline-item="true"] {
      background-color: transparent !important;
      background: transparent !important;
      color: inherit !important;
    }
    [data-timeline-item="true"] a {
       color: inherit !important;
       text-decoration: underline !important;
     }
     /* Ensure links in timeline are visible - override any default browser styles */
     [data-timeline-page="true"] a {
       color: inherit !important;
     }
     [data-timeline-page="true"] a:visited {
       color: inherit !important;
     }
     [data-timeline-page="true"] a:hover {
       color: inherit !important;
     }
     [data-timeline-page="true"] a:active {
       color: inherit !important;
     }
    [data-display-link="true"] {
      color: inherit !important;
    }
    .feed-header a {
      color: inherit !important;
      text-decoration: underline;
    }
    @media only screen and (max-width: 768px) {
      [data-timeline-header="true"] {
        font-size: 1.125rem !important; /* 18px equivalent */
      }
    }
    /* Auto-hide scrollbars */
    .auto-hide-scroll {
      scrollbar-width: thin;
      scrollbar-color: rgba(128, 128, 128, 0.4) transparent;
    }
    .auto-hide-scroll::-webkit-scrollbar {
      width: 6px;
      height: 6px;
    }
    .auto-hide-scroll::-webkit-scrollbar-track {
      background: transparent;
    }
    .auto-hide-scroll::-webkit-scrollbar-thumb {
      background-color: rgba(128, 128, 128, 0.4);
      border-radius: 3px;
      opacity: 0;
      transition: opacity 0.3s ease;
    }
    .auto-hide-scroll:hover::-webkit-scrollbar-thumb {
      opacity: 1;
    }
    /* Main content scrollbar */
    #main-content {
      scrollbar-width: thin;
      scrollbar-color: rgba(128, 128, 128, 0.3) transparent;
    }
    #main-content::-webkit-scrollbar {
      width: 8px;
      height: 8px;
    }
    #main-content::-webkit-scrollbar-track {
      background: transparent;
    }
    #main-content::-webkit-scrollbar-thumb {
      background-color: rgba(128, 128, 128, 0.3);
      border-radius: 4px;
    }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/color-thief/2.3.2/color-thief.umd.js"></script>
  </head>
  <body>
    <div id="app">
      <div style="display: flex; justify-content: center; align-items: center; height: 100vh; color: #f0f0f0; font-family: system-ui, sans-serif; font-size: 18px; background: #121212;">Loading QuickHeadlines...</div>
    </div>
    <script src="/elm.js"></script>
  <script>
    window.feedHeaderCache = window.feedHeaderCache || {};

    window.extractHeaderColors = function() {
      if (typeof ColorThief === 'undefined') return;
      const colorThief = new ColorThief();

      document.querySelectorAll('.feed-header[data-use-adaptive-colors="true"]').forEach(header => {
        // Skip if already processed
        if (header.dataset.adaptive === 'true') return;

        // Skip timeline headers explicitly - they should never be colored
        if (header.dataset.timelineHeader === 'true') {
          header.dataset.adaptive = 'true';
          return;
        }

        // Ensure element has .feed-header class (defense in depth)
        if (!header.classList.contains('feed-header')) {
          return;
        }

        // Use favicon src as cache key (more reliable than URL matching)
        const img = header.querySelector('img');
        const imgSrc = img ? img.getAttribute('src') : null;
        const faviconKey = imgSrc || 'default';

        // Check cache by favicon path
        if (window.feedHeaderCache[faviconKey]) {
          const cached = window.feedHeaderCache[faviconKey];
          header.style.backgroundColor = cached.bg;
          header.style.color = cached.text;
          const link = header.querySelector('a');
          if (link) {
            link.style.setProperty('color', cached.text, 'important');
            link.style.textDecoration = 'none';
          }
          header.dataset.adaptive = 'true';
          return;
        }

        // Search for image in the header row
        if (!img) return;
        if (!imgSrc) return;

        // Create a temporary image to extract colors from
        const tempImg = new Image();
        tempImg.crossOrigin = 'Anonymous';
        tempImg.src = imgSrc;

        tempImg.onload = function() {
          try {
            // Use getColor for single dominant color (works better with small images)
            const color = colorThief.getColor(tempImg);
            if (!color || !color.length) return;

            const [r, g, b] = color;
            const yiq = ((r * 299) + (g * 587) + (b * 114)) / 1000;
            const textColor = (yiq >= 128) ? '#1f2937' : '#ffffff';
            const bgColor = 'rgb(' + r + ',' + g + ',' + b + ')';
            const link = header.querySelector('a');

            header.style.backgroundColor = bgColor;
            header.style.color = textColor;
            if (link) {
              link.style.setProperty('color', textColor, 'important');
              link.style.textDecoration = 'none';
            }

            // Store by favicon key for reliable cache lookup
            if (faviconKey) {
              window.feedHeaderCache[faviconKey] = { bg: bgColor, text: textColor };
            }

            // Save extracted colors to database using feed URL if available
            const feedUrl = link ? link.href : null;
            if (feedUrl) {
              fetch('/api/header_color', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ feed_url: feedUrl, color: bgColor, text_color: textColor })
              }).catch(e => {});
            }

            header.dataset.adaptive = 'true';
          } catch (e) {
            // Silently fail - color extraction is optional
          }
        };
       });
     };

    (function() {
      var appElement = document.getElementById('app');
      if (!appElement) {
        console.error('app element not found');
        return;
      }

      var savedTheme = localStorage.getItem('quickheadlines-theme');
      var prefersDark = false;
      if (savedTheme) {
        prefersDark = savedTheme === 'dark';
      } else {
        prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
      }
      
      // Check if we should restore a previously saved page
      var savedPage = localStorage.getItem('quickheadlines-page');
      if (savedPage && savedPage !== window.location.pathname) {
        console.log('Restoring saved page:', savedPage);
        window.history.replaceState(null, '', savedPage);
      }

      try {
         console.log('Initializing Elm...');
          var app = Elm.Main.init({
            node: appElement,
            flags: {
              width: window.innerWidth,
              height: window.innerHeight,
              prefersDark: prefersDark,
              timestamp: Date.now()
            }
          });
         console.log('Elm initialized successfully');

          if (app.ports && app.ports.saveTheme) {
            app.ports.saveTheme.subscribe(function(theme) {
              localStorage.setItem('quickheadlines-theme', theme);
            });
          }
          
          if (app.ports && app.ports.saveCurrentPage) {
            app.ports.saveCurrentPage.subscribe(function(page) {
              console.log('Saving current page:', page);
              localStorage.setItem('quickheadlines-page', page);
            });
          }

         window.addEventListener('resize', function() {
           // Handle resize if needed
         });

         // Extract colors after Elm renders
         setTimeout(window.extractHeaderColors, 500);
         setTimeout(window.extractHeaderColors, 1500);

         // Set up single MutationObserver for both color extraction and sentinel observation
          let sentinelObserver = null;
          let observerRetries = 0;
          const maxRetries = 50; // Retry for up to 5 seconds (50 * 100ms)
          
          const observeSentinel = () => {
            if (app.ports && app.ports.onNearBottom) {
              const sentinel = document.getElementById('scroll-sentinel');
              console.log('Checking sentinel (attempt ' + (observerRetries + 1) + '):', { exists: !!sentinel, sentinelObserver: !!sentinelObserver });
              if (sentinel && !sentinelObserver) {
                console.log('Setting up IntersectionObserver for sentinel');
                // Use rootMargin to trigger observer when element is within 500px of viewport bottom
                sentinelObserver = new IntersectionObserver((entries) => {
                  entries.forEach(entry => {
                    console.log('Intersection event:', { isIntersecting: entry.isIntersecting, target: entry.target.id, ratio: entry.intersectionRatio });
                    if (entry.isIntersecting) {
                      console.log('Near bottom detected - sending true');
                      app.ports.onNearBottom.send(true);
                    } else {
                      console.log('No longer near bottom - sending false');
                      app.ports.onNearBottom.send(false);
                    }
                  });
                 }, { threshold: 0, rootMargin: '500px' });

                sentinelObserver.observe(sentinel);
                const rect = sentinel.getBoundingClientRect();
                console.log('IntersectionObserver set up for sentinel, position:', { top: rect.top, bottom: rect.bottom, height: rect.height, viewportHeight: window.innerHeight });
                observerRetries = 0;
              } else if (!sentinel && sentinelObserver) {
                sentinelObserver.disconnect();
                sentinelObserver = null;
              } else if (!sentinel && !sentinelObserver && observerRetries < maxRetries) {
                observerRetries++;
                console.log('Sentinel not found, retrying in 100ms...');
                setTimeout(observeSentinel, 100);
              }
            }
          };

         // Debounce function for mutations
         let mutationTimeout = null;
         const debouncedMutation = () => {
           if (mutationTimeout) clearTimeout(mutationTimeout);
           mutationTimeout = setTimeout(() => {
             window.extractHeaderColors();
             observeSentinel();
           }, 300);
         };

         // Single mutation observer for both color extraction and sentinel
         const mutationObserver = new MutationObserver(debouncedMutation);
         mutationObserver.observe(document.body, { childList: true, subtree: true });

          // Try to observe sentinel immediately
          observeSentinel();


       } catch(e) {
         console.error('Elm init error:', e);
         appElement.innerHTML = '<p style="color: red;">Error: ' + e.message + '</p>';
       }
       
       // Add favicon fallback handling
       setTimeout(function() {
         document.querySelectorAll('img[src*="favicons"], img[alt*="favicon"], img[alt*="Feed favicon"]').forEach(function(img) {
           if (img.src && img.src !== '') {
             img.onerror = function() {
               // Try to extract domain from the image src or nearby text
               var src = img.getAttribute('src');
               var fallbackDomain = '';
               
               // Try to find a feed link nearby to extract domain
               var parent = img.closest('[data-feed-url]');
               if (parent) {
                 fallbackDomain = parent.getAttribute('data-feed-url');
               }
               
               if (!fallbackDomain && src) {
                 // Try to extract domain from current src
                 try {
                   var url = new URL(src);
                   fallbackDomain = url.hostname || '';
                 } catch (e) {}
               }
               
               // Use Google favicon service as fallback
               if (fallbackDomain) {
                 img.src = 'https://www.google.com/s2/favicons?domain=' + encodeURIComponent(fallbackDomain) + '&sz=64';
               } else {
                 // Last resort: use a generic favicon placeholder
                 img.src = 'data:image/svg+xml,%3Csvg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"%3E%3Ccircle cx="8" cy="8" r="7" fill="%23ccc"/%3E%3C/svg%3E';
               }
             };
           }
         });
       }, 500);
       
       // Also add mutation observer to handle dynamically added images
       var faviconObserver = new MutationObserver(function(mutations) {
         mutations.forEach(function(mutation) {
           if (mutation.addedNodes.length) {
             mutation.addedNodes.forEach(function(node) {
               if (node.nodeType === 1) { // Element node
                 var images = node.querySelectorAll ? node.querySelectorAll('img[src*="favicons"], img[alt*="favicon"], img[alt*="Feed favicon"]') : [];
                 images.forEach(function(img) {
                   if (img.onerror === null) {
                     img.onerror = arguments.callee;
                   }
                 });
               }
             });
           }
         });
       });
       
       faviconObserver.observe(appElement, { childList: true, subtree: true });
     })();
  </script>
</body>
</html>
