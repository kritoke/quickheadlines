<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>QuickHeadlines</title>
      <style>
       @font-face {
         font-family: "Inter var";
         src: url("/fonts/Inter-Variable.woff2") format("woff2");
         font-weight: 100 900;
         font-style: normal;
         font-display: swap;
       }
       * { box-sizing: border-box; }
       html, body { margin: 0; padding: 0; height: 100%; overflow-x: hidden !important; overflow-y: auto; }
       #app { width: 100vw; min-height: 100vh; background: #ffffff; overflow-x: hidden !important; }
      [data-timeline-page="true"] { overflow-x: hidden; }
     @media (min-width: 1024px) {
       [data-timeline-page="true"] [data-semantic="main-content-scroll"] > *:first-child {
         padding-top: 0 !important;
       }
     }
       [data-page="home"] { overflow-y: auto; height: auto; overflow-x: hidden; }
       .feed-header { transition: background-color 0.3s ease, color 0.3s ease; }

       [data-timeline-page="true"] [data-adaptive]:not(.feed-header) {
         background-color: transparent !important;
         background: transparent !important;
       }
       [data-timeline-item="true"] {
         background-color: transparent !important;
         background: transparent !important;
       }
       [data-timeline-item="true"] a {
         text-decoration: underline !important;
       }
       [data-timeline-item="true"] a {
         color: inherit !important;
       }
       .feed-header a {
         color: inherit !important;
         text-decoration: underline;
       }
     /\* Auto-hide scrollbars - cannot be done in Elm due to pseudo-elements \*/
    .auto-hide-scroll {
      overflow-y: auto;
    }
    .auto-hide-scroll::-webkit-scrollbar {
      width: 6px;
      height: 6px;
    }
    .auto-hide-scroll::-webkit-scrollbar-track {
      background: transparent;
    }
    .auto-hide-scroll::-webkit-scrollbar-thumb {
      background-color: rgba(128, 128, 128, 0.4);
      border-radius: 3px;
    }
     #main-content {
       overflow-y: auto;
       overflow-x: hidden !important;
     }
    #main-content::-webkit-scrollbar {
      width: 8px;
      height: 8px;
    }
    #main-content::-webkit-scrollbar-track {
      background: transparent;
    }
    #main-content::-webkit-scrollbar-thumb {
      background-color: rgba(128, 128, 128, 0.3);
      border-radius: 4px;
    }
    @media (min-width: 768px) {
      body .font-size-11 { font-size: 14px !important; }
      body .font-size-12 { font-size: 15px !important; }
      body .font-size-13 { font-size: 16px !important; }
      body .font-size-14 { font-size: 17px !important; }
      body .font-size-15 { font-size: 18px !important; }
      body .font-size-16 { font-size: 18px !important; }
      body .font-size-18 { font-size: 20px !important; }
      body .font-size-20 { font-size: 22px !important; }
       body .qh-favicon {
         display: inline-flex !important;
         align-items: center !important;
         justify-content: center !important;
         width: 18px !important;
         height: 18px !important;
         margin-right: 8px !important;
         vertical-align: middle !important;
       }
       [data-page="home"] .tab-link,
       [data-page="home"] .tab-link:hover,
       [data-page="home"] .tab-link:active,
       [data-page="home"] .tab-link:focus,
       [data-page="home"] button,
       [data-page="home"] button:hover,
       [data-page="home"] button:active,
       [data-page="home"] button:focus {
         box-shadow: none !important;
         text-shadow: none !important;
       }
       @keyframes qh-fade-in {
         from { opacity: 0; transform: translateY(8px); }
         to { opacity: 1; transform: translateY(0); }
       }
        @keyframes qh-fade-out {
         from { opacity: 1; transform: translateY(0); }
         to { opacity: 0; transform: translateY(-8px); }
       }
        @keyframes qh-insert {
          from { opacity: 0; transform: translateY(12px) scale(0.997); }
          60% { opacity: 1; transform: translateY(-2px) scale(1.001); }
          to { opacity: 1; transform: translateY(0) scale(1); }
        }
        /* Logo styles removed - now using inline styles */
          .qh-load-more {
           display: inline-flex;
           align-items: center;
           justify-content: center;
           background: #f1f5f9;
           color: #64748b;
           border-radius: 6px;
           padding: 4px 12px;
           border: none;
           box-shadow: none;
           transition: all 140ms ease;
           cursor: pointer;
           font-weight: 500;
           font-size: 12px;
           margin-top: 16px;
           width: auto;
           min-width: unset;
         }
         .qh-load-more:hover {
           background: #e2e8f0;
           color: #475569;
         }
         .qh-load-more:active {
           background: #cbd5e1;
         }
           .qh-load-more:focus {
             outline: none;
           }
           html[data-theme="dark"] .qh-load-more,
           html[data-theme="dark"] .qh-load-more span,
           html[data-theme="dark"] .qh-load-more button {
             background: #334155 !important;
             color: #f8fafc !important;
             border-color: #475569 !important;
           }
           html[data-theme="dark"] .qh-load-more:hover,
           html[data-theme="dark"] .qh-load-more:hover span,
           html[data-theme="dark"] .qh-load-more:hover button {
             background: #475569 !important;
             color: #fff !important;
           }
           html[data-theme="dark"] .qh-load-more:active,
           html[data-theme="dark"] .qh-load-more:active span,
           html[data-theme="dark"] .qh-load-more:active button {
             background: #1e293b !important;
           }
          .qh-notification {
          position: fixed !important;
          right: 12px !important;
          bottom: 12px !important;
          z-index: 1200 !important;
          background: rgba(17,24,39,0.9);
          color: #fff;
          padding: 6px 10px;
          border-radius: 999px;
          font-size: 12px;
          pointer-events: none;
          box-shadow: 0 6px 18px rgba(2,6,23,0.5);
        }
          /* Desktop site header styling */
          .qh-site-header { padding-left: 0; padding-right: 0; }
          @media (min-width: 640px) {
            .qh-site-header { padding-left: 24px; padding-right: 24px; }
          }
        </style>
     <script src="https://cdnjs.cloudflare.com/ajax/libs/color-thief/2.3.2/color-thief.umd.js"></script>
       <script>
         function fixHeaderColors() {
           // Fix text colors for ALL headers to ensure readable text
           document.querySelectorAll('.feed-header').forEach(header => {
             const bgColor = header.style.backgroundColor;
             if (!bgColor || bgColor === 'transparent') return;

            // Extract RGB from any rgb() format
            const match = bgColor.match(/(\d+),\s*(\d+),\s*(\d+)/);
            if (!match) return;

            const r = parseInt(match[1]);
            const g = parseInt(match[2]);
            const b = parseInt(match[3]);

            // Calculate readable text color using YIQ
            const yiq = ((r * 299) + (g * 587) + (b * 114)) / 1000;
            const textColor = yiq >= 128 ? '#1f2937' : '#ffffff';

            // Apply to all text elements in the header - title, link, URL
            header.style.color = textColor;

            const link = header.querySelector('a');
            if (link) {
              link.style.color = textColor;
              link.style.setProperty('color', textColor, 'important');
            }

            const subText = header.querySelector('[data-display-link="true"]');
            if (subText) {
              subText.style.color = textColor;
              subText.style.opacity = '';
            }
          });
        }

        window.extractHeaderColors = function() {
         if (typeof ColorThief === 'undefined') return;
         const colorThief = new ColorThief();

         // Only extract colors for headers that DON'T have server-provided colors
         document.querySelectorAll('.feed-header:not([data-use-adaptive-colors="true"])').forEach(header => {
           if (header.dataset.adaptive === 'true') return;
           if (header.closest('[data-timeline-item="true"]')) {
             header.dataset.adaptive = 'true';
             return;
           }
           if (header.dataset.timelineHeader === 'true') {
             header.dataset.adaptive = 'true';
             return;
           }
           if (!header.classList.contains('feed-header')) return;

           const img = header.querySelector('img');
           const imgSrc = img ? img.getAttribute('src') : null;
           const faviconKey = imgSrc || 'default';

           if (window.feedHeaderCache[faviconKey]) {
             const cached = window.feedHeaderCache[faviconKey];
             header.style.backgroundColor = cached.bg;
             header.style.color = cached.text;
             const link = header.querySelector('a');
            if (link) {
              link.style.setProperty('color', cached.text, 'important');
              link.style.textDecoration = 'none';
            }
            header.dataset.adaptive = 'true';
            return;
          }

          if (!img || !imgSrc) return;

          const tempImg = new Image();
          tempImg.crossOrigin = 'Anonymous';
          tempImg.src = imgSrc;

          tempImg.onload = function() {
            try {
              const color = colorThief.getColor(tempImg);
              if (!color || !color.length) return;

              const [r, g, b] = color;
              const yiq = ((r * 299) + (g * 587) + (b * 114)) / 1000;
              const textColor = (yiq >= 128) ? '#1f2937' : '#ffffff';
              const bgColor = 'rgb(' + r + ',' + g + ',' + b + ')';
              const link = header.querySelector('a');

              header.style.backgroundColor = bgColor;
              header.style.color = textColor;
              if (link) {
                link.style.setProperty('color', textColor, 'important');
                link.style.textDecoration = 'none';
              }

              if (faviconKey) {
                window.feedHeaderCache[faviconKey] = { bg: bgColor, text: textColor };
              }

              const feedUrl = link ? link.href : null;
              if (feedUrl) {
                fetch('/api/header_color', {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({ feed_url: feedUrl, color: bgColor, text_color: textColor })
                }).catch(e => {});
              }

              header.dataset.adaptive = 'true';
            } catch (e) {}
          };
        });
      };

      // Fix cached header colors in dark mode
      window.fixHeaderColors = fixHeaderColors;
    </script>
  </head>
  <body>
    <div id="app">
      <div style="display: flex; justify-content: center; align-items: center; height: 100vh; color: #111827; font-family: system-ui, sans-serif; font-size: 18px; background: #ffffff;">Loading QuickHeadlines...</div>
    </div>
    <script>document.write('<script src="/elm.js?v=' + Date.now() + '"><\/script>');</script>
  <script>
     // Header color cache with localStorage persistence (7-day expiration)
     window.feedHeaderCache = {};
     const HEADER_CACHE_KEY = 'qh_header_colors';
     const HEADER_CACHE_EXPIRY = 7 * 24 * 60 * 60 * 1000; // 7 days in milliseconds

     // Load cached colors from localStorage
     window.loadHeaderColorsFromCache = function() {
       try {
         const cached = localStorage.getItem(HEADER_CACHE_KEY);
         if (cached) {
           const parsed = JSON.parse(cached);
           const now = Date.now();
           // Filter out expired entries
           Object.keys(parsed).forEach(key => {
             const entry = parsed[key];
             if (entry.timestamp && (now - entry.timestamp) > HEADER_CACHE_EXPIRY) {
               delete parsed[key];
             }
           });
           // Save cleaned cache back
           localStorage.setItem(HEADER_CACHE_KEY, JSON.stringify(parsed));
           window.feedHeaderCache = parsed;
           return parsed;
         }
       } catch (e) {
         // localStorage unavailable or quota exceeded
       }
       return {};
     };

     // Apply cached colors immediately on page load
     window.applyCachedHeaderColors = function() {
       const cached = window.loadHeaderColorsFromCache();
       Object.keys(cached).forEach(key => {
         const entry = cached[key];
         // Find headers by favicon src matching the cache key
         const headers = document.querySelectorAll('.feed-header[data-use-adaptive-colors="true"]');
         headers.forEach(header => {
           const img = header.querySelector('img');
           if (img && img.getAttribute('src') === key) {
             header.style.backgroundColor = entry.bg;
             header.style.color = entry.text;
             const link = header.querySelector('a');
             if (link) {
               link.style.setProperty('color', entry.text, 'important');
             }
           }
         });
       });
     };

     // Save extracted colors to localStorage
     window.saveHeaderColorToCache = function(key, bg, text) {
       try {
         const cached = window.loadHeaderColorsFromCache();
         cached[key] = { bg: bg, text: text, timestamp: Date.now() };
         localStorage.setItem(HEADER_CACHE_KEY, JSON.stringify(cached));
         window.feedHeaderCache = cached;
       } catch (e) {
         // localStorage unavailable or quota exceeded
       }
     };

     window.extractHeaderColors = function() {
      if (typeof ColorThief === 'undefined') return;
      const colorThief = new ColorThief();

       var allHeaders = document.querySelectorAll('.feed-header[data-use-adaptive-colors="true"]');

      allHeaders.forEach(header => {
        var inTimeline = header.closest('[data-timeline-item="true"]') !== null;

        // Skip if already processed
        if (header.dataset.adaptive === 'true') {
          header.dataset.adaptive = 'true';
          return;
        }

        // Skip ANY header that's inside a timeline item - use theme colors instead
        if (inTimeline) {
          header.dataset.adaptive = 'true';
          return;
        }

        // Skip timeline headers explicitly
        if (header.dataset.timelineHeader === 'true') {
          header.dataset.adaptive = 'true';
          return;
        }

        // Ensure element has .feed-header class (defense in depth)
        if (!header.classList.contains('feed-header')) {
          return;
        }

        // Use favicon src as cache key (more reliable than URL matching)
        const img = header.querySelector('img');
        const imgSrc = img ? img.getAttribute('src') : null;
        const faviconKey = imgSrc || 'default';

        // Check cache by favicon path
        if (window.feedHeaderCache[faviconKey]) {
          const cached = window.feedHeaderCache[faviconKey];
          header.style.backgroundColor = cached.bg;
          header.style.color = cached.text;
          const link = header.querySelector('a');
          if (link) {
            link.style.setProperty('color', cached.text, 'important');
            link.style.textDecoration = 'none';
          }
          header.dataset.adaptive = 'true';
          return;
        }

        // Search for image in the header row
        if (!img) return;
        if (!imgSrc) return;

        // Create a temporary image to extract colors from
        const tempImg = new Image();
        tempImg.crossOrigin = 'Anonymous';
        tempImg.src = imgSrc;

        tempImg.onload = function() {
          try {
            // Use getColor for single dominant color (works better with small images)
            const color = colorThief.getColor(tempImg);
            if (!color || !color.length) return;

            const [r, g, b] = color;
            const yiq = ((r * 299) + (g * 587) + (b * 114)) / 1000;
            const textColor = (yiq >= 128) ? '#1f2937' : '#ffffff';
            const bgColor = 'rgb(' + r + ',' + g + ',' + b + ')';
            const link = header.querySelector('a');

             header.style.backgroundColor = bgColor;
             header.style.color = textColor;
             if (link) {
               link.style.setProperty('color', textColor, 'important');
               link.style.textDecoration = 'none';
             }

             // Save to localStorage cache
             if (faviconKey && faviconKey !== 'default') {
               window.saveHeaderColorToCache(faviconKey, bgColor, textColor);
             }

             // Save extracted colors to database using feed URL if available
             const feedUrl = link ? link.href : null;
             if (feedUrl) {
               fetch('/api/header_color', {
                 method: 'POST',
                 headers: { 'Content-Type': 'application/json' },
                 body: JSON.stringify({ feed_url: feedUrl, color: bgColor, text_color: textColor })
               }).catch(e => {});
             }

             header.dataset.adaptive = 'true';
          } catch (e) {
            // Silently fail - color extraction is optional
          }
        };
       });
     };

    (function() {
      var appElement = document.getElementById('app');
      if (!appElement) {
        console.error('app element not found');
        return;
      }

      var savedTheme = localStorage.getItem('quickheadlines-theme');
      var prefersDark = false;
      if (savedTheme) {
        prefersDark = savedTheme === 'dark';
      } else {
        prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
      }
      
        // Apply theme to document
        if (prefersDark) {
          document.documentElement.setAttribute('data-theme', 'dark');
        } else {
          document.documentElement.setAttribute('data-theme', 'light');
        }

        // Apply cached header colors immediately to prevent flash
        setTimeout(window.applyCachedHeaderColors, 10);

         // Fix header colors for dark mode
        if (prefersDark) {
          setTimeout(window.fixHeaderColors, 100);
          setTimeout(window.fixHeaderColors, 200);
        }
      
       // Check if we should restore a previously saved page
        var savedPage = localStorage.getItem('quickheadlines-page');
        if (savedPage && savedPage !== window.location.pathname) {
          window.history.replaceState(null, '', savedPage);
        }

        // Get saved tab from localStorage
        var savedTab = localStorage.getItem('quickheadlines-tab');

         try {
             var app = Elm.Main.init({
              node: appElement,
              flags: {
                width: window.innerWidth,
                height: window.innerHeight,
                prefersDark: prefersDark,
                timestamp: Date.now(),
                savedTab: savedTab
              }
            });
           window.app = app; // Expose for debugging

           if (app.ports && app.ports.saveTheme) {
             app.ports.saveTheme.subscribe(function(theme) {
               localStorage.setItem('quickheadlines-theme', theme);
             });
           }

             if (app.ports && app.ports.saveCurrentPage) {
               app.ports.saveCurrentPage.subscribe(function(page) {
                 localStorage.setItem('quickheadlines-page', page);
               });
             }

             if (app.ports && app.ports.saveActiveTab) {
               app.ports.saveActiveTab.subscribe(function(tab) {
                 localStorage.setItem('quickheadlines-tab', tab);
               });
             }

            window.addEventListener('resize', function() {
            // Handle resize if needed
          });

           // Extract colors after Elm renders
          setTimeout(window.extractHeaderColors, 500);
          setTimeout(window.extractHeaderColors, 1500);

           // Fix header colors after color extraction
          setTimeout(function() {
            if (window.fixHeaderColors) window.fixHeaderColors();
          }, 1000);
          setTimeout(function() {
            if (window.fixHeaderColors) window.fixHeaderColors();
          }, 2500);

          // Watch for theme changes
          new MutationObserver(function(mutations) {
            mutations.forEach(function(mutation) {
              if (mutation.attributeName === 'data-theme' && window.fixHeaderColors) {
                window.fixHeaderColors();
              }
            });
          }).observe(document.documentElement, { attributes: true });

          // Listen for OS theme changes and sync to Elm when no user preference is saved
          var themeMediaQuery = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)');
          if (themeMediaQuery) {
            themeMediaQuery.addEventListener('change', function(e) {
              var savedTheme = localStorage.getItem('quickheadlines-theme');
              if (savedTheme) {
                // User has explicitly set a theme; honor it and do not update
                return;
              }
              var isDark = e.matches;
              document.documentElement.setAttribute('data-theme', isDark ? 'dark' : 'light');
              if (app.ports && app.ports.envThemeChanged) {
                app.ports.envThemeChanged.send(isDark);
              }
            });
          }

          // Set up single MutationObserver for both color extraction and sentinel observation
          let sentinelObserver = null;
          let observerRetries = 0;
          const maxRetries = 50; // Retry for up to 5 seconds (50 * 100ms)
          
           const observeSentinel = () => {
             if (app.ports && app.ports.onNearBottom) {
               const sentinel = document.getElementById('scroll-sentinel');
                 if (sentinel && !sentinelObserver) {
                 // Try to find the nearest scrollable ancestor and use it as the observer root so
                 // the observer works when the sentinel is inside a scroll container (not the viewport).
                 function findScrollParent(el) {
                   var parent = el.parentElement;
                   while (parent) {
                     var style = window.getComputedStyle(parent);
                     var overflowY = (style.overflowY || '').toLowerCase();
                     // Only accept explicit scrolling containers
                     if (overflowY === 'auto' || overflowY === 'scroll' || overflowY === 'overlay') return parent;
                     parent = parent.parentElement;
                   }
                   return null;
                 }

                 // Prefer an actual scroll container. Only use the timeline page element as the root
                 // if it is explicitly scrollable; otherwise fall back to the viewport (null).
                 var potentialRoot = document.querySelector('[data-timeline-page="true"]');
                 var scrollRoot = findScrollParent(sentinel) || null;
                 if (!scrollRoot && potentialRoot) {
                   var potentialStyle = window.getComputedStyle(potentialRoot);
                   var potOverflow = (potentialStyle.overflowY || '').toLowerCase();
                   if (potOverflow === 'auto' || potOverflow === 'scroll' || potOverflow === 'overlay') {
                     scrollRoot = potentialRoot;
                   }
                 }

                 // Use rootMargin to trigger observer when element is within 500px of viewport/container bottom
                 // Only trigger near-bottom when sentinel is actually visible AND content is scrolled near bottom
                 sentinelObserver = new IntersectionObserver((entries) => {
                   entries.forEach(entry => {
                     // Only consider it "near bottom" if the sentinel is actually intersecting
                     // and the scroll position is near the bottom
                    if (entry.isIntersecting) {
                      // Use the inner scrollable container for scroll position
                      const scrollContainer = document.querySelector('#main-content > div');
                      if (scrollContainer) {
                        try {
                          const scrollTop = scrollContainer.scrollTop;
                          const scrollHeight = scrollContainer.scrollHeight;
                          const clientHeight = scrollContainer.clientHeight;
                           const maxScroll = scrollHeight - clientHeight;
                           const isScrolledNearBottom = maxScroll > 0 && scrollTop >= maxScroll - 600;

                           if (isScrolledNearBottom) {
                             try { app.ports.onNearBottom.send(true); } catch(e) { }
                           } else {
                           }
                         } catch(e) {
                         }
                       }
                     } else {
                       try { app.ports.onNearBottom.send(false); } catch(e) { }
                     }
                   });
                  }, { threshold: 0, root: null, rootMargin: '0px' });

                sentinelObserver.observe(sentinel);
                // Fallback: if IntersectionObserver doesn't report expected values in
                // some environments (nested scrollers, weird layout), also attach a
                // scroll/resize listener that computes sentinel position against the
                // chosen root and sends onNearBottom when within 500px of the bottom.
                (function() {
                  var lastSentinelState = null;
                  function checkSentinelVisibility() {
                    try {
                      if (!sentinel) return;
                      var rect = sentinel.getBoundingClientRect();
                      // Always use viewport for calculation
                       var near = rect.top <= (window.innerHeight + 500) && rect.bottom >= -500;

                       if (near !== lastSentinelState) {
                         lastSentinelState = near;
                         try { app.ports.onNearBottom.send(near); } catch(e) { }
                       }
                     } catch (e) {
                       // ignore measurement errors
                     }
                   }

                   // Poll for sentinel position changes
                   var pollingInterval = setInterval(function() {
                     checkSentinelVisibility();
                   }, 100);

                   // Also listen to scroll on scroll container if available
                   if (scrollRoot) {
                     scrollRoot.addEventListener('scroll', function() {
                       // Immediate check on scroll
                       checkSentinelVisibility();
                     }, { passive: true });
                   }
                   window.addEventListener('resize', checkSentinelVisibility);

                   // Run an initial check
                   setTimeout(checkSentinelVisibility, 50);
                 })();

                 observerRetries = 0;
               } else if (!sentinel && sentinelObserver) {
                 sentinelObserver.disconnect();
                 sentinelObserver = null;
               } else if (!sentinel && !sentinelObserver && observerRetries < maxRetries) {
                 observerRetries++;
                 setTimeout(observeSentinel, 100);
               }
             }
           };

          // Debounce function for mutations
         let mutationTimeout = null;
         const debouncedMutation = () => {
           if (mutationTimeout) clearTimeout(mutationTimeout);
           mutationTimeout = setTimeout(() => {
             window.extractHeaderColors();
             observeSentinel();
           }, 300);
         };

         // Single mutation observer for both color extraction and sentinel
         const mutationObserver = new MutationObserver(debouncedMutation);
         mutationObserver.observe(document.body, { childList: true, subtree: true });

          // Try to observe sentinel immediately
          observeSentinel();


       } catch(e) {
         console.error('Elm init error:', e);
         appElement.innerHTML = '<p style="color: red;">Error: ' + e.message + '</p>';
       }
       
       // Add favicon fallback handling
       setTimeout(function() {
         document.querySelectorAll('img[src*="favicons"], img[alt*="favicon"], img[alt*="Feed favicon"]').forEach(function(img) {
           if (img.src && img.src !== '') {
             img.onerror = function() {
               // Try to extract domain from the image src or nearby text
               var src = img.getAttribute('src');
               var fallbackDomain = '';
               
               // Try to find a feed link nearby to extract domain
               var parent = img.closest('[data-feed-url]');
               if (parent) {
                 fallbackDomain = parent.getAttribute('data-feed-url');
               }
               
               if (!fallbackDomain && src) {
                 // Try to extract domain from current src
                 try {
                   var url = new URL(src);
                   fallbackDomain = url.hostname || '';
                 } catch (e) {}
               }
               
               // Use Google favicon service as fallback
               if (fallbackDomain) {
                 img.src = 'https://www.google.com/s2/favicons?domain=' + encodeURIComponent(fallbackDomain) + '&sz=64';
               } else {
                 // Last resort: use a generic favicon placeholder
                 img.src = 'data:image/svg+xml,%3Csvg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"%3E%3Ccircle cx="8" cy="8" r="7" fill="%23ccc"/%3E%3C/svg%3E';
               }
             };
           }
         });
       }, 500);
       
        // Also add mutation observer to handle dynamically added images
        var faviconObserver = new MutationObserver(function(mutations) {
          mutations.forEach(function(mutation) {
            if (mutation.addedNodes.length) {
              mutation.addedNodes.forEach(function(node) {
                if (node.nodeType === 1) { // Element node
                  var images = node.querySelectorAll ? node.querySelectorAll('img[src*="favicons"], img[alt*="favicon"], img[alt*="Feed favicon"]') : [];
                  images.forEach(function(img) {
                    if (img.onerror === null) {
                      img.onerror = arguments.callee;
                    }
                  });
                }
              });
            }
          });
        });

        faviconObserver.observe(appElement, { childList: true, subtree: true });

        // Fix header colors after initial load
        setTimeout(fixHeaderColors, 2000);
        setTimeout(fixHeaderColors, 4000);
       })();
     </script>
</body>
</html>
