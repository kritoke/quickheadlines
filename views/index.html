<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>QuickHeadlines</title>
      <style>
       @font-face {
         font-family: "Inter var";
         src: url("/fonts/Inter-Variable.woff2") format("woff2");
         font-weight: 100 900;
         font-style: normal;
         font-display: swap;
       }
       * { box-sizing: border-box; }
       html, body { margin: 0; padding: 0; height: 100%; overflow-x: hidden !important; overflow-y: auto; }
       #app { width: 100vw; min-height: 100vh; background: #ffffff; overflow-x: hidden !important; }
      [data-timeline-page="true"] { overflow-x: hidden; }
     @media (min-width: 1024px) {
       [data-timeline-page="true"] [data-semantic="main-content-scroll"] > *:first-child {
         padding-top: 0 !important;
       }
     }
        [data-page="home"] { overflow-y: auto; height: auto; overflow-x: hidden; }
        .feed-header { transition: background-color 0.3s ease, color 0.3s ease; }

       [data-timeline-page="true"] [data-adaptive]:not(.feed-header) {
         background-color: transparent !important;
         background: transparent !important;
       }
        [data-timeline-item="true"] {
          background-color: transparent !important;
          background: transparent !important;
        }
       [data-timeline-item="true"] a {
          text-decoration: underline !important;
        }
        /* Force readable timeline link colors per theme to protect against
           inline styles applied by Elm during re-renders. This uses !important
           so it overrides accidental inline colors (without needing JS). */
        html[data-theme="light"] [data-timeline-item="true"] a,
        html[data-theme="light"] [data-timeline-item="true"] [data-server-fallback-color] { color: rgb(17, 24, 39) !important; }
        html[data-theme="dark"] [data-timeline-item="true"] a,
        html[data-theme="dark"] [data-timeline-item="true"] [data-server-fallback-color] { color: rgb(248, 250, 252) !important; }

        .feed-header a {
          color: inherit;
          text-decoration: underline;
        }
     /\* Auto-hide scrollbars - cannot be done in Elm due to pseudo-elements \*/
    .auto-hide-scroll {
      overflow-y: auto;
    }
    .auto-hide-scroll::-webkit-scrollbar {
      width: 6px;
      height: 6px;
    }
    .auto-hide-scroll::-webkit-scrollbar-track {
      background: transparent;
    }
    .auto-hide-scroll::-webkit-scrollbar-thumb {
      background-color: rgba(128, 128, 128, 0.4);
      border-radius: 3px;
    }
     #main-content {
       overflow-y: auto;
       overflow-x: hidden !important;
     }
    #main-content::-webkit-scrollbar {
      width: 8px;
      height: 8px;
    }
    #main-content::-webkit-scrollbar-track {
      background: transparent;
    }
    #main-content::-webkit-scrollbar-thumb {
      background-color: rgba(128, 128, 128, 0.3);
      border-radius: 4px;
    }
    @media (min-width: 768px) {
      body .font-size-11 { font-size: 14px !important; }
      body .font-size-12 { font-size: 15px !important; }
      body .font-size-13 { font-size: 16px !important; }
      body .font-size-14 { font-size: 17px !important; }
      body .font-size-15 { font-size: 18px !important; }
      body .font-size-16 { font-size: 18px !important; }
      body .font-size-18 { font-size: 20px !important; }
      body .font-size-20 { font-size: 22px !important; }
       body .qh-favicon {
         display: inline-flex !important;
         align-items: center !important;
         justify-content: center !important;
         width: 18px !important;
         height: 18px !important;
         margin-right: 8px !important;
         vertical-align: middle !important;
       }
       [data-page="home"] .tab-link,
       [data-page="home"] .tab-link:hover,
       [data-page="home"] .tab-link:active,
       [data-page="home"] .tab-link:focus,
       [data-page="home"] button,
       [data-page="home"] button:hover,
       [data-page="home"] button:active,
       [data-page="home"] button:focus {
         box-shadow: none !important;
         text-shadow: none !important;
       }
       @keyframes qh-fade-in {
         from { opacity: 0; transform: translateY(8px); }
         to { opacity: 1; transform: translateY(0); }
       }
        @keyframes qh-fade-out {
         from { opacity: 1; transform: translateY(0); }
         to { opacity: 0; transform: translateY(-8px); }
       }
        @keyframes qh-insert {
          from { opacity: 0; transform: translateY(12px) scale(0.997); }
          60% { opacity: 1; transform: translateY(-2px) scale(1.001); }
          to { opacity: 1; transform: translateY(0) scale(1); }
        }
        /* Logo styles removed - now using inline styles */
          .qh-load-more {
           display: inline-flex;
           align-items: center;
           justify-content: center;
           background: #f1f5f9;
           color: #64748b;
           border-radius: 6px;
           padding: 4px 12px;
           border: none;
           box-shadow: none;
           transition: all 140ms ease;
           cursor: pointer;
           font-weight: 500;
           font-size: 12px;
           margin-top: 16px;
           width: auto;
           min-width: unset;
         }
         .qh-load-more:hover {
           background: #e2e8f0;
           color: #475569;
         }
         .qh-load-more:active {
           background: #cbd5e1;
         }
           .qh-load-more:focus {
             outline: none;
           }
           html[data-theme="dark"] .qh-load-more,
           html[data-theme="dark"] .qh-load-more span,
           html[data-theme="dark"] .qh-load-more button {
             background: #334155 !important;
             color: #f8fafc !important;
             border-color: #475569 !important;
           }
           html[data-theme="dark"] .qh-load-more:hover,
           html[data-theme="dark"] .qh-load-more:hover span,
           html[data-theme="dark"] .qh-load-more:hover button {
             background: #475569 !important;
             color: #fff !important;
           }
           html[data-theme="dark"] .qh-load-more:active,
           html[data-theme="dark"] .qh-load-more:active span,
           html[data-theme="dark"] .qh-load-more:active button {
             background: #1e293b !important;
           }
          .qh-notification {
          position: fixed !important;
          right: 12px !important;
          bottom: 12px !important;
          z-index: 1200 !important;
          background: rgba(17,24,39,0.9);
          color: #fff;
          padding: 6px 10px;
          border-radius: 999px;
          font-size: 12px;
          pointer-events: none;
          box-shadow: 0 6px 18px rgba(2,6,23,0.5);
        }
          /* Desktop site header styling */
          .qh-site-header { padding-left: 0; padding-right: 0; }
          @media (min-width: 640px) {
            .qh-site-header { padding-left: 24px; padding-right: 24px; }
          }
        </style>
     <script src="https://cdnjs.cloudflare.com/ajax/libs/color-thief/2.3.2/color-thief.umd.js"></script>
        <script>
          function fixHeaderColors() {
            try {
              // Fix feed headers that lack readable text colors
              document.querySelectorAll('.feed-header').forEach(header => {
                try {
                  const bgColor = header.style.backgroundColor;
                  if (!bgColor || bgColor === 'transparent') return;

                  // If header already has a usable non-variable color, skip
                  const currentColor = header.style.color;
                  if (currentColor && !currentColor.startsWith('var(') && currentColor !== '') return;

                  const match = ('' + bgColor).match(/(\d+),\s*(\d+),\s*(\d+)/);
                  if (!match) return;
                  const r = parseInt(match[1]), g = parseInt(match[2]), b = parseInt(match[3]);
                  const yiq = ((r * 299) + (g * 587) + (b * 114)) / 1000;
                  const textColor = yiq >= 128 ? '#1f2937' : '#ffffff';

                  // If server-provided colors are enabled, verify contrast first
                  if (header.getAttribute && header.getAttribute('data-use-server-colors') === 'true') {
                    try {
                      const comp = window.getComputedStyle(header).color;
                      let node = header, bg = '';
                      while (node) {
                        const st = window.getComputedStyle(node);
                        const bc = st.backgroundColor;
                        if (bc && bc !== 'rgba(0, 0, 0, 0)' && bc !== 'transparent') { bg = bc; break; }
                        node = node.parentElement;
                      }
                      if (bg) {
                        const pRGB = s => { const m = ('' + s).match(/(\d+),\s*(\d+),\s*(\d+)/); return m ? [parseInt(m[1]),parseInt(m[2]),parseInt(m[3])] : null; };
                        const toLin = c => { const v = c/255; return v <= 0.03928 ? v/12.92 : Math.pow((v+0.055)/1.055,2.4); };
                        const fg = pRGB(comp);
                        const bgRgb = pRGB(bg);
                        if (fg && bgRgb) {
                          const Lf = 0.2126*toLin(fg[0]) + 0.7152*toLin(fg[1]) + 0.0722*toLin(fg[2]);
                          const Lb = 0.2126*toLin(bgRgb[0]) + 0.7152*toLin(bgRgb[1]) + 0.0722*toLin(bgRgb[2]);
                          const ratio = (Math.max(Lf,Lb) + 0.05) / (Math.min(Lf,Lb) + 0.05);
                          if (ratio >= 4.5) return; // server colors are acceptable
                        }
                      }
                    } catch (e) {}
                  }

                  header.style.color = textColor;
                  const link = header.querySelector('a');
                  if (link) link.style.color = textColor;
                  const subText = header.querySelector('[data-display-link="true"]');
                  if (subText) { subText.style.color = textColor; subText.style.opacity = ''; }
                } catch (e) {}
              });

              // Defensive fix for timeline item links
              try {
                const theme = document.documentElement.getAttribute('data-theme');
                const isLight = theme === 'light';
                const isDark = theme === 'dark';
                document.querySelectorAll('[data-timeline-item="true"] a').forEach(link => {
                  try {
                    const linkComp = window.getComputedStyle(link).color;
                    const compMatch = ('' + linkComp).match(/(\d+)\s*,\s*(\d+)\s*,\s*(\d+)/);
                    let needsFix = false;
                    let targetColor = '';
                    if (compMatch) {
                      const lr = parseInt(compMatch[1]), lg = parseInt(compMatch[2]), lb = parseInt(compMatch[3]);
                      const lYiq = ((lr * 299) + (lg * 587) + (lb * 114)) / 1000;
                      if (isLight && lYiq >= 200) { needsFix = true; targetColor = 'rgb(17, 24, 39)'; }
                      else if (isDark && lYiq < 140) { needsFix = true; targetColor = 'rgb(248, 250, 252)'; }
                    } else {
                      if (isLight && linkComp === 'rgb(255, 255, 255)') { needsFix = true; targetColor = 'rgb(17, 24, 39)'; }
                      else if (isDark && linkComp === 'rgb(0, 0, 0)') { needsFix = true; targetColor = 'rgb(248, 250, 252)'; }
                    }
                    if (needsFix) link.style.color = targetColor;
                  } catch (e) {}
                });
              } catch (e) {}
            } catch (e) {}
          }

          // Run immediately after DOM loads and after Elm renders
          document.addEventListener('DOMContentLoaded', function() {
            setTimeout(function() { if (typeof window.fixHeaderColors === 'function') window.fixHeaderColors(); }, 100);
            setTimeout(function() { if (typeof window.fixHeaderColors === 'function') window.fixHeaderColors(); }, 500);
            setTimeout(function() { if (typeof window.fixHeaderColors === 'function') window.fixHeaderColors(); }, 1500);
            setTimeout(function() { if (typeof window.fixHeaderColors === 'function') window.fixHeaderColors(); }, 3000);
          });

      window.extractHeaderColors = function() {
           if (typeof ColorThief === 'undefined') return;
           const colorThief = new ColorThief();

           // Only extract colors for headers that DON'T have server-provided colors
           // Headers with server colors have data-use-server-colors="true" set by Elm
           document.querySelectorAll('.feed-header:not([data-use-server-colors="true"])').forEach(header => {
             // Skip timeline headers - they use theme colors
             if (header.dataset.timelineHeader === 'true') {
               header.dataset.adaptive = 'true';
               return;
             }

             // Ensure element has .feed-header class (defense in depth)
             if (!header.classList.contains('feed-header')) return;

             const img = header.querySelector('img');
             const imgSrc = img ? img.getAttribute('src') : null;
             const faviconKey = imgSrc || 'default';

             if (window.feedHeaderCache[faviconKey]) {
               const cached = window.feedHeaderCache[faviconKey];
               header.style.backgroundColor = cached.bg;
               header.style.color = cached.text;
               const link = header.querySelector('a');
                if (link) {
                    // Respect server-provided color flags; however Elm now passes
                    // server colors via `data-server-header-text-color` to avoid
                    // inline inheritance issues. Prefer that attribute if present.
                    const serverColor = (link.getAttribute && link.getAttribute('data-server-header-text-color')) || (link.getAttribute && link.getAttribute('data-use-server-colors') === 'true' ? link.style.color : null);
                    if (serverColor) {
                      try {
                        const theme = document.documentElement.getAttribute('data-theme');
                        const isWhite = /255,\s*255,\s*255/.test(serverColor) || /#fff/i.test(serverColor) || /white/i.test(serverColor);
                        if (theme === 'dark' || !isWhite) {
                          link.style.color = serverColor;
                        }
                        link.style.textDecoration = 'none';
                      } catch(e) { link.style.color = serverColor; }
                    } else {
                     // Don't force a white text color in light theme (it will be unreadable
                     // unless there's a background pill). Only apply cached text color when
                     // it won't produce white-on-light or when we're in dark theme.
                     try {
                       const theme = document.documentElement.getAttribute('data-theme');
                       const isWhite = /255,\s*255,\s*255/.test(cached.text) || /#fff/i.test(cached.text) || /white/i.test(cached.text);
                       if (theme === 'dark' || !isWhite) {
                         link.style.color = cached.text;
                       }
                       link.style.textDecoration = 'none';
                     } catch (e) {
                       link.style.color = cached.text;
                       link.style.textDecoration = 'none';
                     }
                   }
                }
               header.dataset.adaptive = 'true';
               return;
             }

             if (!img || !imgSrc) return;

             const tempImg = new Image();
             tempImg.crossOrigin = 'Anonymous';
             tempImg.src = imgSrc;

             tempImg.onload = function() {
               try {
                 const color = colorThief.getColor(tempImg);
                 if (!color || !color.length) return;

                 const [r, g, b] = color;
                 const yiq = ((r * 299) + (g * 587) + (b * 114)) / 1000;
                 const textColor = (yiq >= 128) ? '#1f2937' : '#ffffff';
                 const bgColor = 'rgb(' + r + ',' + g + ',' + b + ')';
                 const link = header.querySelector('a');

                  header.style.backgroundColor = bgColor;
                  header.style.color = textColor;
                if (link) {
                  // Prefer a server-provided text color attribute if Elm supplied it
                  const serverColor = link.getAttribute && link.getAttribute('data-server-header-text-color');
                  if (serverColor) {
                    try {
                      const theme = document.documentElement.getAttribute('data-theme');
                      const isWhite = /255,\s*255,\s*255/.test(serverColor) || /#fff/i.test(serverColor) || /white/i.test(serverColor);
                      if (theme === 'dark' || !isWhite) {
                        link.style.color = serverColor;
                      }
                      link.style.textDecoration = 'none';
                    } catch (e) { link.style.color = serverColor; }
                  } else {
                    // Do not override if Elm already applied server colors on the link
                    if (!(link.getAttribute && link.getAttribute('data-use-server-colors') === 'true')) {
                      try {
                        const theme = document.documentElement.getAttribute('data-theme');
                        const isWhite = /255,\s*255,\s*255/.test(textColor) || /#fff/i.test(textColor) || /white/i.test(textColor);
                        if (theme === 'dark' || !isWhite) {
                          link.style.color = textColor;
                        }
                        link.style.textDecoration = 'none';
                      } catch (e) {
                        link.style.color = textColor;
                        link.style.textDecoration = 'none';
                      }
                    }
                  }
                }

                 if (faviconKey) {
                   window.feedHeaderCache[faviconKey] = { bg: bgColor, text: textColor };
                 }

                 const feedUrl = link ? link.href : null;
                 if (feedUrl) {
                   fetch('/api/header_color', {
                     method: 'POST',
                     headers: { 'Content-Type': 'application/json' },
                     body: JSON.stringify({ feed_url: feedUrl, color: bgColor, text_color: textColor })
                   }).catch(e => {});
                 }

                 header.dataset.adaptive = 'true';
               } catch (e) {}
             };
        });
       };

      // Extract timeline item colors similarly to header extraction, but keyed
      // by the feed favicon or feed URL when possible. This ensures timeline
      // links get deterministic readable colors without requiring a page
      // refresh.
      window.extractTimelineItemColors = function() {
        if (typeof ColorThief === 'undefined') return;
        const colorThief = new ColorThief();

        document.querySelectorAll('[data-timeline-item="true"]').forEach(item => {
          // Skip if already adaptive
          if (item.dataset.adaptive === 'true') return;

          // If Elm already rendered server-provided colors anywhere inside
          // this timeline item, verify contrast and only override when
          // the server-provided color is insufficient. Elm marks elements
          // with `data-use-server-colors="true"` when it intentionally
          // applies server-side themes; we must not blindly skip them.
          const serverElem = item.querySelector('[data-use-server-colors="true"]');
          if (serverElem) {
            try {
              // Prefer reading declared server color attribute if Elm provided it.
              const attrColor = serverElem.getAttribute('data-server-header-text-color') || serverElem.dataset.serverHeaderTextColor;
              const comp = attrColor || window.getComputedStyle(serverElem).color;
              // Find nearest non-transparent background for contrast check
              let node = serverElem;
              let bg = '';
              while (node) {
                const st = window.getComputedStyle(node);
                const bc = st.backgroundColor;
                if (bc && bc !== 'rgba(0, 0, 0, 0)' && bc !== 'transparent') { bg = bc; break; }
                node = node.parentElement;
              }
              if (!bg) bg = window.getComputedStyle(document.body).backgroundColor || 'rgb(255,255,255)';

              function pRGB(s){ const m = (''+s).match(/(\d+),\s*(\d+),\s*(\d+)/); return m ? [parseInt(m[1]),parseInt(m[2]),parseInt(m[3])] : null; }
              function toLin(c){ const v = c/255; return v <= 0.03928 ? v/12.92 : Math.pow((v+0.055)/1.055, 2.4); }

              const fg = pRGB(comp);
              const bgRgb = pRGB(bg);
              if (fg && bgRgb) {
                const Lf = 0.2126*toLin(fg[0]) + 0.7152*toLin(fg[1]) + 0.0722*toLin(fg[2]);
                const Lb = 0.2126*toLin(bgRgb[0]) + 0.7152*toLin(bgRgb[1]) + 0.0722*toLin(bgRgb[2]);
                const ratio = (Math.max(Lf, Lb) + 0.05) / (Math.min(Lf, Lb) + 0.05);
                if (ratio < 4.5) {
                  // Pick a readable color based on background brightness (YIQ)
                  const yiq = ((bgRgb[0] * 299) + (bgRgb[1] * 587) + (bgRgb[2] * 114)) / 1000;
                  const target = yiq >= 128 ? 'rgb(17, 24, 39)' : 'rgb(248, 250, 252)';
                  try {
                    // Apply with !important so Elm re-renders are less likely to override
                    serverElem.style.setProperty('color', target, 'important');
                    serverElem.setAttribute('data-js-override', 'true');
                    // Also try to find a nearby link and apply the same override
                    const nearbyLink = serverElem.closest('a') || serverElem.querySelector('a');
                    if (nearbyLink) {
                      try { nearbyLink.style.setProperty('color', target, 'important'); nearbyLink.setAttribute('data-js-override', 'true'); } catch(e) {}
                    }
                  } catch(e) {}
                }
              }
            } catch (e) {}
            item.dataset.adaptive = 'true';
            return;
          }

          const link = item.querySelector('a');
          const img = item.querySelector('img');
          const imgSrc = img ? img.getAttribute('src') : null;
          const key = imgSrc || (item.getAttribute('data-feed-url') || 'default');

          // If we have a cached color for the favicon, apply it
          if (window.feedHeaderCache[key]) {
            const cached = window.feedHeaderCache[key];
            if (link) {
              // Respect server-provided flag on the link itself (do not override).
              if (link.getAttribute('data-use-server-colors') === 'true') {
                item.dataset.adaptive = 'true';
                return;
              }

              // Only apply in dark theme or when link currently looks dark
              const comp = window.getComputedStyle(link).color;
              const m = ('' + comp).match(/(\d+),\s*(\d+),\s*(\d+)/);
              let shouldApply = false;
              if (m) {
                const lr = parseInt(m[1]);
                const lg = parseInt(m[2]);
                const lb = parseInt(m[3]);
                const yiq = ((lr * 299) + (lg * 587) + (lb * 114)) / 1000;
                shouldApply = (yiq < 140) || (document.documentElement.getAttribute('data-theme') === 'dark');
              } else {
                shouldApply = (comp === 'rgb(0, 0, 0)');
              }

              if (shouldApply) {
                link.style.color = cached.text;
              }
            }
            item.dataset.adaptive = 'true';
            return;
          }

          // If there is no favicon image, still mark adaptive if a fallback
          // color is provided by Elm via data-server-fallback-color so we
          // can apply readable colors without needing to extract from an image.
          if (!img || !imgSrc) {
            const fallback = item.querySelector('[data-server-fallback-color]');
            if (fallback && link) {
              try {
                const fb = fallback.getAttribute('data-server-fallback-color');
                if (fb) {
                  // Apply via CSS priority so Elm inline styles (if any) don't win.
                  link.style.setProperty('color', fb, 'important');
                }
              } catch(e) {}
            }
            item.dataset.adaptive = 'true';
            return;
          }

          const tempImg = new Image();
          tempImg.crossOrigin = 'Anonymous';
          tempImg.src = imgSrc;
          tempImg.onload = function() {
            try {
              const color = colorThief.getColor(tempImg);
              if (!color || !color.length) return;
              const [r,g,b] = color;
              const bg = 'rgb(' + r + ',' + g + ',' + b + ')';
              const yiq = ((r*299)+(g*587)+(b*114))/1000;
              const textColor = yiq >= 128 ? '#1f2937' : '#ffffff';
               if (link) {
                 // Do not override if Elm already applied server colors on the link
                 if (link.getAttribute('data-use-server-colors') !== 'true') {
                   link.style.color = textColor;
                 }
               }
              window.feedHeaderCache[key] = { bg: bg, text: textColor, timestamp: Date.now() };
              item.dataset.adaptive = 'true';
            } catch(e) {}
          };
        });
      };

        // Fix cached header colors in dark mode
      window.fixHeaderColors = fixHeaderColors;
      
      // Enforce readable timeline link colors repeatedly until Elm settles.
      window.enforceReadableTimelineLinks = function() {
        // Debug recorder (enabled via localStorage key 'qh-debug-colors' === '1')
        // Records only override/relevant events and prints a concise summary at
        // the end of each enforcement run to avoid flooding the console.
        window.qhColorDebug = window.qhColorDebug || (function() {
          function enabled() { try { return localStorage.getItem('qh-debug-colors') === '1'; } catch (e) { return false; } }
          function fmtRgb(a) { return a && a.length ? 'rgb(' + a.join(',') + ')' : String(a); }
          function shortText(el) { try { return el && el.textContent ? el.textContent.trim().slice(0,80) : ''; } catch(e) { return ''; } }
          const entries = [];
          function record(obj) { if (!enabled()) return; try { entries.push(obj); } catch(e) {} }
          function flush() {
            try {
              if (!enabled() || !entries.length) return;
              // Summary counts
              const summary = entries.reduce((acc, e) => { acc[e.type] = (acc[e.type]||0) + 1; return acc; }, {});
              console.groupCollapsed('[qh-color-debug] enforcement summary', new Date().toISOString());
              console.log('total events:', entries.length, 'summary:', summary);
              // Show a concise table of up to 40 events
              const table = entries.slice(0,40).map(e => ({type: e.type, who: e.href || e.text || shortText(e.el) || '', reason: e.reason || '', target: e.target || '', ratio: e.ratio || e.srvRatio || '' }));
              console.table(table);
              if (entries.length > 40) console.log('...+' + (entries.length - 40) + ' more events');
              // If verbose flag set, dump full entries grouped
              if (localStorage.getItem('qh-debug-colors-detailed') === '1') {
                entries.forEach(e => { console.groupCollapsed('[qh-color-debug]', e.type); console.log(e); console.groupEnd(); });
              }
              console.groupEnd();
            } catch(e) {}
            // clear after flush
            entries.length = 0;
          }
          return { enabled: enabled, record: record, flush: flush, fmtRgb: fmtRgb, shortText: shortText };
        })();

        function parseRGB(s) {
          if (!s) return null;
          s = ('' + s).trim();
          // rgb(...) or rgba(...)
          let m = s.match(/(\d+),\s*(\d+),\s*(\d+)/);
          if (m) return [parseInt(m[1]), parseInt(m[2]), parseInt(m[3])];
          // hex #rrggbb
          m = s.match(/^#?([0-9a-fA-F]{6})$/);
          if (m) {
            const hex = m[1];
            return [parseInt(hex.substr(0,2),16), parseInt(hex.substr(2,2),16), parseInt(hex.substr(4,2),16)];
          }
          return null;
        }
        function toLin(c){ const v = c/255; return v <= 0.03928 ? v/12.92 : Math.pow((v+0.055)/1.055, 2.4); }
        function luminance(rgb){ return 0.2126*toLin(rgb[0]) + 0.7152*toLin(rgb[1]) + 0.0722*toLin(rgb[2]); }
        function contrastRatio(fg, bg){ const Lf = luminance(fg); const Lb = luminance(bg); const l1 = Math.max(Lf,Lb); const l2 = Math.min(Lf,Lb); return (l1+0.05)/(l2+0.05); }

        document.querySelectorAll('[data-timeline-item="true"] a[data-display-link="true"]').forEach(link => {
          try {
            // If JS already overrode this link, skip
            if (link.getAttribute && link.getAttribute('data-js-override') === 'true') return;

            const fgComp = window.getComputedStyle(link).color;
            const fg = parseRGB(fgComp) || [0,0,0];

            // Find nearest ancestor with non-transparent background. If the
            // timeline item itself is transparent, try to locate the feed
            // header/card background (feed-header) which may provide the true
            // visual background for contrast purposes.
            let node = link;
            let bg = null;
            while (node) {
              const st = window.getComputedStyle(node);
              const bc = st.backgroundColor;
              if (bc && bc !== 'rgba(0, 0, 0, 0)' && bc !== 'transparent') { bg = bc; break; }
              // Prefer feed-header ancestor if present
              if (node.classList && node.classList.contains('feed-header')) { bg = window.getComputedStyle(node).backgroundColor; break; }
              node = node.parentElement;
            }
            if (!bg) {
              const header = link.closest('.feed-header');
              if (header) bg = window.getComputedStyle(header).backgroundColor;
            }
            if (!bg) bg = window.getComputedStyle(document.body).backgroundColor || 'rgb(255,255,255)';
            const bgRgb = parseRGB(bg) || [255,255,255];

            // If a server-provided text color exists on the link or nearby
            // element, prefer checking its contrast first and override if needed.
            const serverProvided = (link.getAttribute && (link.getAttribute('data-server-header-text-color') || link.dataset.serverHeaderTextColor));
            if (serverProvided) {
              try {
                const serverRgb = parseRGB(serverProvided);
                if (serverRgb) {
                  const srvRatio = contrastRatio(serverRgb, bgRgb);
                  if (srvRatio < 4.5) {
                    // server color fails contrast; pick readable target and force it
                    const yiq = ((bgRgb[0]*299)+(bgRgb[1]*587)+(bgRgb[2]*114))/1000;
                    const target = yiq >= 128 ? 'rgb(17, 24, 39)' : 'rgb(248, 250, 252)';
                    try { link.style.setProperty('color', target, 'important'); link.setAttribute('data-js-override','true'); } catch(e) {}
                    try { window.qhColorDebug && window.qhColorDebug.record({ type: 'override-link-server-failing', href: link.href, serverProvided: serverProvided, serverRgb: window.qhColorDebug.fmtRgb(serverRgb), bg: bg, bgRgb: window.qhColorDebug.fmtRgb(bgRgb), target: target, srvRatio: srvRatio, reason: 'server-fails-contrast' }); } catch(e) {}
                  }
                  // skip the rest of checks since server color was authoritative
                  else { try { window.qhColorDebug && window.qhColorDebug.record({ type: 'server-color-ok', href: link.href, serverProvided: serverProvided, srvRatio: srvRatio, reason: 'server-ok' }); } catch(e) {} }
                  return;
                }
              } catch(e) {}
            }

            const ratio = contrastRatio(fg, bgRgb);
            if (ratio < 4.5) {
              // Pick readable color based on background brightness (YIQ)
              const yiq = ((bgRgb[0]*299)+(bgRgb[1]*587)+(bgRgb[2]*114))/1000;
              const target = yiq >= 128 ? 'rgb(17, 24, 39)' : 'rgb(248, 250, 252)';
              try { link.style.setProperty('color', target, 'important'); link.setAttribute('data-js-override','true'); } catch(e) {}
              try { window.qhColorDebug && window.qhColorDebug.record({ type: 'override-link-contrast', href: link.href, comp: fgComp, bg: bg, bgRgb: window.qhColorDebug.fmtRgb(bgRgb), target: target, ratio: ratio, reason: 'link-contrast' }); } catch(e) {}
            }
          } catch(e) {}
        });

        // Also enforce readable colors for other server-provided elements inside
        // timeline items (site name chips, badges) which may not be links.
        document.querySelectorAll('[data-timeline-item="true"] [data-use-server-colors="true"], [data-timeline-item="true"] [data-server-fallback-color]').forEach(el => {
          try {
            // Skip links already handled
            if (el.tagName && el.tagName.toLowerCase() === 'a') return;

            // Prefer explicit server-provided color attribute when present
            const serverAttr = (el.getAttribute && (el.getAttribute('data-server-header-text-color') || el.getAttribute('data-server-fallback-color')));
            const compColor = serverAttr || window.getComputedStyle(el).color;
            const fg = parseRGB(compColor) || [0,0,0];

            // Find nearest non-transparent background
            let node = el;
            let bg = null;
            while (node) {
              const st = window.getComputedStyle(node);
              const bc = st.backgroundColor;
              if (bc && bc !== 'rgba(0, 0, 0, 0)' && bc !== 'transparent') { bg = bc; break; }
              if (node.classList && node.classList.contains('feed-header')) { bg = window.getComputedStyle(node).backgroundColor; break; }
              node = node.parentElement;
            }
            if (!bg) bg = window.getComputedStyle(document.body).backgroundColor || 'rgb(255,255,255)';
            const bgRgb = parseRGB(bg) || [255,255,255];

            // If serverAttr exists, check its contrast first and override if insufficient
            if (serverAttr) {
              const srvRgb = parseRGB(serverAttr);
              if (srvRgb) {
                const srvRatio = contrastRatio(srvRgb, bgRgb);
                if (srvRatio < 4.5) {
                  const yiq = ((bgRgb[0]*299)+(bgRgb[1]*587)+(bgRgb[2]*114))/1000;
                  const target = yiq >= 128 ? 'rgb(17, 24, 39)' : 'rgb(248, 250, 252)';
                  try { el.style.setProperty('color', target, 'important'); el.setAttribute('data-js-override','true'); } catch(e) {}
                  try { window.qhColorDebug && window.qhColorDebug.record({ type: 'override-chip-server-failing', text: el.textContent && el.textContent.trim().slice(0,80), serverAttr: serverAttr, srvRgb: window.qhColorDebug.fmtRgb(srvRgb), bg: bg, bgRgb: window.qhColorDebug.fmtRgb(bgRgb), target: target, srvRatio: srvRatio, reason: 'chip-server-fails' }); } catch(e) {}
                }
                return;
              }
            }

            const ratio = contrastRatio(fg, bgRgb);
            if (ratio < 4.5) {
              const yiq = ((bgRgb[0]*299)+(bgRgb[1]*587)+(bgRgb[2]*114))/1000;
              const target = yiq >= 128 ? 'rgb(17, 24, 39)' : 'rgb(248, 250, 252)';
              try { el.style.setProperty('color', target, 'important'); el.setAttribute('data-js-override','true'); } catch(e) {}
              try { window.qhColorDebug && window.qhColorDebug.record({ type: 'override-chip-contrast', text: el.textContent && el.textContent.trim().slice(0,80), compColor: compColor, bg: bg, bgRgb: window.qhColorDebug.fmtRgb(bgRgb), target: target, ratio: ratio, reason: 'chip-contrast' }); } catch(e) {}
            }
          } catch(e) {}
        });
      };

      // Observe mutations to re-run enforcement when Elm updates DOM.
      // Guard against running before <body> exists (some platforms execute
      // this script in the <head> early). If document.body is not available
      // yet, wait for DOMContentLoaded and then start observing.
      (function() {
        const mo = new MutationObserver(function() { try { window.enforceReadableTimelineLinks(); } catch(e) {} });

        function startObserver() {
          const target = document.body || document.documentElement;
          if (!target || target.nodeType !== 1) return;
          try {
            mo.observe(target, { childList: true, subtree: true, attributes: true, attributeFilter: ['style', 'class', 'data-use-server-colors'] });
          } catch (e) {
            // observing failed for some reason - silently ignore
          }
        }

        if (document.body) {
          startObserver();
        } else {
          document.addEventListener('DOMContentLoaded', startObserver);
        }

        // Also run repeatedly for a short window to cover Elm re-renders
        let enforcementRuns = 0;
        const enforceInterval = setInterval(function() {
            try { window.enforceReadableTimelineLinks(); } catch(e) {}
            enforcementRuns++;
            if (enforcementRuns > 40) { clearInterval(enforceInterval); try { mo.disconnect(); } catch(e) {} }
          }, 100);
        })();
        // Flush any recorded debug entries after each enforcement window
        try { setInterval(function(){ try { window.qhColorDebug && window.qhColorDebug.flush(); } catch(e) {} }, 1000); } catch(e) {}
    </script>
  </head>
  <body>
    <div id="app">
      <div style="display: flex; justify-content: center; align-items: center; height: 100vh; color: #111827; font-family: system-ui, sans-serif; font-size: 18px; background: #ffffff;">Loading QuickHeadlines...</div>
    </div>
    <script>document.write('<script src="/elm.js?v=' + Date.now() + '"><\/script>');</script>
  <script>
     // Header color cache with localStorage persistence (7-day expiration)
     window.feedHeaderCache = {};
     const HEADER_CACHE_KEY = 'qh_header_colors';
     const HEADER_CACHE_EXPIRY = 7 * 24 * 60 * 60 * 1000; // 7 days in milliseconds

     // Load cached colors from localStorage
     window.loadHeaderColorsFromCache = function() {
       try {
         const cached = localStorage.getItem(HEADER_CACHE_KEY);
         if (cached) {
           const parsed = JSON.parse(cached);
           const now = Date.now();
           // Filter out expired entries
           Object.keys(parsed).forEach(key => {
             const entry = parsed[key];
             if (entry.timestamp && (now - entry.timestamp) > HEADER_CACHE_EXPIRY) {
               delete parsed[key];
             }
           });
           // Save cleaned cache back
           localStorage.setItem(HEADER_CACHE_KEY, JSON.stringify(parsed));
           window.feedHeaderCache = parsed;
           return parsed;
         }
       } catch (e) {
         // localStorage unavailable or quota exceeded
       }
       return {};
     };

      // Apply cached colors immediately on page load
      window.applyCachedHeaderColors = function() {
        const cached = window.loadHeaderColorsFromCache();
        Object.keys(cached).forEach(key => {
          const entry = cached[key];
          // Find headers without server colors (data-use-server-colors is NOT set)
           const headers = document.querySelectorAll('.feed-header:not([data-use-server-colors="true"])');
          headers.forEach(header => {
            const img = header.querySelector('img');
            if (img && img.getAttribute('src') === key) {
              header.style.backgroundColor = entry.bg;
              header.style.color = entry.text;
              const link = header.querySelector('a');
               if (link) {
                 // Avoid using !important from JS; use inline style which can be
                 // overridden by server-provided colors and respects later re-renders.
                 link.style.color = entry.text;
               }
            }
          });
        });
      };

     // Save extracted colors to localStorage
     window.saveHeaderColorToCache = function(key, bg, text) {
       try {
         const cached = window.loadHeaderColorsFromCache();
         cached[key] = { bg: bg, text: text, timestamp: Date.now() };
         localStorage.setItem(HEADER_CACHE_KEY, JSON.stringify(cached));
         window.feedHeaderCache = cached;
       } catch (e) {
         // localStorage unavailable or quota exceeded
       }
      };

        window.extractHeaderColors = function() {
         if (typeof ColorThief === 'undefined') return;
         const colorThief = new ColorThief();

         // Only extract colors for headers that DON'T have server-provided colors
         // Headers with server colors have data-use-server-colors="true" set by Elm
         var allHeaders = document.querySelectorAll('.feed-header:not([data-use-server-colors="true"])');

         allHeaders.forEach(header => {
           // Skip timeline headers - they use theme colors
           if (header.dataset.timelineHeader === 'true') {
             header.dataset.adaptive = 'true';
             return;
           }

           // Ensure element has .feed-header class (defense in depth)
           if (!header.classList.contains('feed-header')) {
             return;
           }

           // Use favicon src as cache key (more reliable than URL matching)
           const img = header.querySelector('img');
           const imgSrc = img ? img.getAttribute('src') : null;
           const faviconKey = imgSrc || 'default';

           // Check cache by favicon path
           if (window.feedHeaderCache[faviconKey]) {
             const cached = window.feedHeaderCache[faviconKey];
             header.style.backgroundColor = cached.bg;
             header.style.color = cached.text;
             const link = header.querySelector('a');
                if (link) {
                  link.style.color = cached.text;
                  link.style.textDecoration = 'none';
                }
             header.dataset.adaptive = 'true';
             return;
           }

           // Skip if no favicon image
           if (!img || !imgSrc) return;

           // Create a temporary image to extract colors from
           const tempImg = new Image();
           tempImg.crossOrigin = 'Anonymous';
           tempImg.src = imgSrc;

           tempImg.onload = function() {
             try {
               // Use getColor for single dominant color (works better with small images)
               const color = colorThief.getColor(tempImg);
               if (!color || !color.length) return;

               const [r, g, b] = color;
               const yiq = ((r * 299) + (g * 587) + (b * 114)) / 1000;
               const textColor = (yiq >= 128) ? '#1f2937' : '#ffffff';
               const bgColor = 'rgb(' + r + ',' + g + ',' + b + ')';
               const link = header.querySelector('a');

               header.style.backgroundColor = bgColor;
               header.style.color = textColor;
                if (link) {
                      try {
                        const theme = document.documentElement.getAttribute('data-theme');
                        const isWhite = /255,\s*255,\s*255/.test(textColor) || /#fff/i.test(textColor) || /white/i.test(textColor);
                        if (theme === 'dark' || !isWhite) {
                          link.style.color = textColor;
                        }
                        link.style.textDecoration = 'none';
                      } catch (e) {
                        link.style.color = textColor;
                        link.style.textDecoration = 'none';
                      }
                }

               // Save to localStorage cache
               if (faviconKey && faviconKey !== 'default') {
                 window.saveHeaderColorToCache(faviconKey, bgColor, textColor);
               }

               // Save extracted colors to database using feed URL if available
               const feedUrl = link ? link.href : null;
               if (feedUrl) {
                 fetch('/api/header_color', {
                   method: 'POST',
                   headers: { 'Content-Type': 'application/json' },
                   body: JSON.stringify({ feed_url: feedUrl, color: bgColor, text_color: textColor })
                 }).catch(e => {});
               }

               header.dataset.adaptive = 'true';
             } catch (e) {
               // Silently fail - color extraction is optional
             }
           };
         });
        };

    (function() {
      var appElement = document.getElementById('app');
      if (!appElement) {
        console.error('app element not found');
        return;
      }

      var savedTheme = localStorage.getItem('quickheadlines-theme');
      var prefersDark = false;
      if (savedTheme) {
         prefersDark = savedTheme === 'dark';
       } else {
         prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
       }
       
         // Apply theme to document
         if (prefersDark) {
           document.documentElement.setAttribute('data-theme', 'dark');
         } else {
           document.documentElement.setAttribute('data-theme', 'light');
         }

         // Fix header colors for headers without server-provided text colors
         // Already scheduled via DOMContentLoaded above
      
       // Check if we should restore a previously saved page
        var savedPage = localStorage.getItem('quickheadlines-page');
        if (savedPage && savedPage !== window.location.pathname) {
          window.history.replaceState(null, '', savedPage);
        }

        // Get saved tab from localStorage
        var savedTab = localStorage.getItem('quickheadlines-tab');

          try {
              // Apply any cached header colors immediately so feed headers
              // render with readable colors before Elm finishes its first render.
              try { if (window.applyCachedHeaderColors) window.applyCachedHeaderColors(); } catch(e) {}

              var app = Elm.Main.init({
               node: appElement,
               flags: {
                width: window.innerWidth,
                height: window.innerHeight,
                prefersDark: prefersDark,
                timestamp: Date.now(),
                savedTab: savedTab
              }
            });
            window.app = app; // Expose for debugging

           if (app.ports && app.ports.saveTheme) {
             app.ports.saveTheme.subscribe(function(theme) {
               localStorage.setItem('quickheadlines-theme', theme);
             });
           }

             if (app.ports && app.ports.saveCurrentPage) {
               app.ports.saveCurrentPage.subscribe(function(page) {
                 localStorage.setItem('quickheadlines-page', page);
               });
             }

             if (app.ports && app.ports.saveActiveTab) {
               app.ports.saveActiveTab.subscribe(function(tab) {
                 localStorage.setItem('quickheadlines-tab', tab);
               });
             }

            window.addEventListener('resize', function() {
            // Handle resize if needed
          });

            // Extract colors after Elm renders
            setTimeout(window.extractHeaderColors, 500);
            setTimeout(window.extractHeaderColors, 1500);
            setTimeout(window.extractTimelineItemColors, 500);
            setTimeout(window.extractTimelineItemColors, 1500);

             // Fix header colors after color extraction
            setTimeout(fixHeaderColors, 1500);
            setTimeout(fixHeaderColors, 3000);

            // Wait for timeline items to stabilize before doing a final enforcement pass.
            // Elm may re-render multiple times; instead of racing with timeouts, wait
            // until the number of timeline items has been stable for a short window
            // then run extraction and enforcement. This reduces the need to refresh.
            function waitForStableCount(selector, timeoutMs, stableWindowMs, cb) {
              const start = Date.now();
              let lastCount = -1;
              let stableSince = Date.now();
              (function check() {
                try {
                  const nodes = document.querySelectorAll(selector);
                  const count = nodes ? nodes.length : 0;
                  if (count === lastCount) {
                    if (Date.now() - stableSince >= stableWindowMs) return cb();
                  } else {
                    lastCount = count;
                    stableSince = Date.now();
                  }
                  if (Date.now() - start > timeoutMs) return cb();
                } catch (e) {
                  // ignore
                }
                setTimeout(check, 150);
              })();
            }

            // Run a final enforcement when the timeline items stop changing for 600ms
            waitForStableCount('[data-timeline-item="true"]', 15000, 600, function() {
              try { window.extractTimelineItemColors(); } catch(e) {}
              try { window.enforceReadableTimelineLinks(); } catch(e) {}
              try { window.fixHeaderColors(); } catch(e) {}
            });

           // Watch for theme changes
            new MutationObserver(function(mutations) {
              mutations.forEach(function(mutation) {
                if (mutation.attributeName === 'data-theme') {
                  // When theme changes, re-run all color enforcement paths.
                  // Use timeouts to allow Elm and CSS to settle before computing contrast.
                  try { 
                    // Clear any JS-applied overrides so we can re-evaluate for the new theme
                    document.querySelectorAll('[data-js-override="true"]').forEach(function(el){
                      try { el.style.removeProperty('color'); } catch(e) {}
                      try { el.removeAttribute('data-js-override'); } catch(e) {}
                    });
                    fixHeaderColors(); 
                  } catch(e) {}
                  setTimeout(function() { try { window.extractHeaderColors(); } catch(e) {} }, 50);
                  setTimeout(function() { try { window.extractTimelineItemColors(); } catch(e) {} }, 100);
                  setTimeout(function() { try { window.enforceReadableTimelineLinks(); } catch(e) {} }, 150);
                }
              });
            }).observe(document.documentElement, { attributes: true });

          // Listen for OS theme changes and sync to Elm when no user preference is saved
          var themeMediaQuery = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)');
          if (themeMediaQuery) {
            themeMediaQuery.addEventListener('change', function(e) {
              var savedTheme = localStorage.getItem('quickheadlines-theme');
              if (savedTheme) {
                // User has explicitly set a theme; honor it and do not update
                return;
              }
              var isDark = e.matches;
              document.documentElement.setAttribute('data-theme', isDark ? 'dark' : 'light');
              if (app.ports && app.ports.envThemeChanged) {
                app.ports.envThemeChanged.send(isDark);
              }
            });
          }

          // Set up single MutationObserver for both color extraction and sentinel observation
          let sentinelObserver = null;
          let observerRetries = 0;
          const maxRetries = 50; // Retry for up to 5 seconds (50 * 100ms)
          
           const observeSentinel = () => {
             if (app.ports && app.ports.onNearBottom) {
               const sentinel = document.getElementById('scroll-sentinel');
                 if (sentinel && !sentinelObserver) {
                 // Try to find the nearest scrollable ancestor and use it as the observer root so
                 // the observer works when the sentinel is inside a scroll container (not the viewport).
                 function findScrollParent(el) {
                   var parent = el.parentElement;
                   while (parent) {
                     var style = window.getComputedStyle(parent);
                     var overflowY = (style.overflowY || '').toLowerCase();
                     // Only accept explicit scrolling containers
                     if (overflowY === 'auto' || overflowY === 'scroll' || overflowY === 'overlay') return parent;
                     parent = parent.parentElement;
                   }
                   return null;
                 }

                 // Prefer an actual scroll container. Only use the timeline page element as the root
                 // if it is explicitly scrollable; otherwise fall back to the viewport (null).
                 var potentialRoot = document.querySelector('[data-timeline-page="true"]');
                 var scrollRoot = findScrollParent(sentinel) || null;
                 if (!scrollRoot && potentialRoot) {
                   var potentialStyle = window.getComputedStyle(potentialRoot);
                   var potOverflow = (potentialStyle.overflowY || '').toLowerCase();
                   if (potOverflow === 'auto' || potOverflow === 'scroll' || potOverflow === 'overlay') {
                     scrollRoot = potentialRoot;
                   }
                 }

                 // Use rootMargin to trigger observer when element is within 500px of viewport/container bottom
                 // Only trigger near-bottom when sentinel is actually visible AND content is scrolled near bottom
                 sentinelObserver = new IntersectionObserver((entries) => {
                   entries.forEach(entry => {
                     // Only consider it "near bottom" if the sentinel is actually intersecting
                     // and the scroll position is near the bottom
                    if (entry.isIntersecting) {
                      // Use the inner scrollable container for scroll position
                      const scrollContainer = document.querySelector('#main-content > div');
                      if (scrollContainer) {
                        try {
                          const scrollTop = scrollContainer.scrollTop;
                          const scrollHeight = scrollContainer.scrollHeight;
                          const clientHeight = scrollContainer.clientHeight;
                           const maxScroll = scrollHeight - clientHeight;
                           const isScrolledNearBottom = maxScroll > 0 && scrollTop >= maxScroll - 600;

                           if (isScrolledNearBottom) {
                             try { app.ports.onNearBottom.send(true); } catch(e) { }
                           } else {
                           }
                         } catch(e) {
                         }
                       }
                     } else {
                       try { app.ports.onNearBottom.send(false); } catch(e) { }
                     }
                   });
                  }, { threshold: 0, root: null, rootMargin: '0px' });

                sentinelObserver.observe(sentinel);
                // Fallback: if IntersectionObserver doesn't report expected values in
                // some environments (nested scrollers, weird layout), also attach a
                // scroll/resize listener that computes sentinel position against the
                // chosen root and sends onNearBottom when within 500px of the bottom.
                (function() {
                  var lastSentinelState = null;
                  function checkSentinelVisibility() {
                    try {
                      if (!sentinel) return;
                      var rect = sentinel.getBoundingClientRect();
                      // Always use viewport for calculation
                       var near = rect.top <= (window.innerHeight + 500) && rect.bottom >= -500;

                       if (near !== lastSentinelState) {
                         lastSentinelState = near;
                         try { app.ports.onNearBottom.send(near); } catch(e) { }
                       }
                     } catch (e) {
                       // ignore measurement errors
                     }
                   }

                   // Poll for sentinel position changes
                   var pollingInterval = setInterval(function() {
                     checkSentinelVisibility();
                   }, 100);

                   // Also listen to scroll on scroll container if available
                   if (scrollRoot) {
                     scrollRoot.addEventListener('scroll', function() {
                       // Immediate check on scroll
                       checkSentinelVisibility();
                     }, { passive: true });
                   }
                   window.addEventListener('resize', checkSentinelVisibility);

                   // Run an initial check
                   setTimeout(checkSentinelVisibility, 50);
                 })();

                 observerRetries = 0;
               } else if (!sentinel && sentinelObserver) {
                 sentinelObserver.disconnect();
                 sentinelObserver = null;
               } else if (!sentinel && !sentinelObserver && observerRetries < maxRetries) {
                 observerRetries++;
                 setTimeout(observeSentinel, 100);
               }
             }
           };

          // Debounce function for mutations
          let mutationTimeout = null;
          const debouncedMutation = () => {
            if (mutationTimeout) clearTimeout(mutationTimeout);
            mutationTimeout = setTimeout(() => {
              window.extractHeaderColors();
              window.extractTimelineItemColors();
              observeSentinel();
            }, 300);
          };

         // Single mutation observer for both color extraction and sentinel
         const mutationObserver = new MutationObserver(debouncedMutation);
         mutationObserver.observe(document.body, { childList: true, subtree: true });

          // Try to observe sentinel immediately
          observeSentinel();


       } catch(e) {
         console.error('Elm init error:', e);
         appElement.innerHTML = '<p style="color: red;">Error: ' + e.message + '</p>';
       }
       
       // Add favicon fallback handling
       setTimeout(function() {
         document.querySelectorAll('img[src*="favicons"], img[alt*="favicon"], img[alt*="Feed favicon"]').forEach(function(img) {
           if (img.src && img.src !== '') {
             img.onerror = function() {
               // Try to extract domain from the image src or nearby text
               var src = img.getAttribute('src');
               var fallbackDomain = '';
               
               // Try to find a feed link nearby to extract domain
               var parent = img.closest('[data-feed-url]');
               if (parent) {
                 fallbackDomain = parent.getAttribute('data-feed-url');
               }
               
               if (!fallbackDomain && src) {
                 // Try to extract domain from current src
                 try {
                   var url = new URL(src);
                   fallbackDomain = url.hostname || '';
                 } catch (e) {}
               }
               
               // Use Google favicon service as fallback
               if (fallbackDomain) {
                 img.src = 'https://www.google.com/s2/favicons?domain=' + encodeURIComponent(fallbackDomain) + '&sz=64';
               } else {
                 // Last resort: use a generic favicon placeholder
                 img.src = 'data:image/svg+xml,%3Csvg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"%3E%3Ccircle cx="8" cy="8" r="7" fill="%23ccc"/%3E%3C/svg%3E';
               }
             };
           }
         });
       }, 500);
       
        // Also add mutation observer to handle dynamically added images
        var faviconObserver = new MutationObserver(function(mutations) {
          mutations.forEach(function(mutation) {
            if (mutation.addedNodes.length) {
              mutation.addedNodes.forEach(function(node) {
                if (node.nodeType === 1) { // Element node
                  var images = node.querySelectorAll ? node.querySelectorAll('img[src*="favicons"], img[alt*="favicon"], img[alt*="Feed favicon"]') : [];
                  images.forEach(function(img) {
                    if (img.onerror === null) {
                      img.onerror = arguments.callee;
                    }
                  });
                }
              });
            }
          });
        });

        faviconObserver.observe(appElement, { childList: true, subtree: true });

        // Final safety fix for any remaining headers
        setTimeout(fixHeaderColors, 5000);
       })();
      </script>
 </body>
</html>
