<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>QuickHeadlines</title>
      <style>
       @font-face {
         font-family: "Inter var";
         src: url("/fonts/Inter-Variable.woff2") format("woff2");
         font-weight: 100 900;
         font-style: normal;
         font-display: swap;
       }
       * { box-sizing: border-box; }
       html, body { margin: 0; padding: 0; height: 100%; overflow-x: hidden !important; overflow-y: auto; }
       #app { width: 100vw; min-height: 100vh; background: #ffffff; overflow-x: hidden !important; }
      [data-timeline-page="true"] { overflow-x: hidden; }
     @media (min-width: 1024px) {
       [data-timeline-page="true"] [data-semantic="main-content-scroll"] > *:first-child {
         padding-top: 0 !important;
       }
     }
        [data-page="home"] { overflow-y: auto; height: auto; overflow-x: hidden; }
        .feed-header { transition: background-color 0.3s ease, color 0.3s ease; }

       [data-timeline-page="true"] [data-adaptive]:not(.feed-header) {
         background-color: transparent !important;
         background: transparent !important;
       }
        [data-timeline-item="true"] {
          background-color: transparent !important;
          background: transparent !important;
        }
       [data-timeline-item="true"] a {
          text-decoration: underline !important;
        }
        /* Force readable timeline link colors per theme to protect against
           inline styles applied by Elm during re-renders. This uses !important
           so it overrides accidental inline colors (without needing JS). */
        html[data-theme="light"] [data-timeline-item="true"] a,
        html[data-theme="light"] [data-timeline-item="true"] [data-server-fallback-color] { color: rgb(17, 24, 39) !important; }
        html[data-theme="dark"] [data-timeline-item="true"] a,
        html[data-theme="dark"] [data-timeline-item="true"] [data-server-fallback-color] { color: rgb(248, 250, 252) !important; }

        .feed-header a {
          color: inherit;
          text-decoration: underline;
        }
     /\* Auto-hide scrollbars - cannot be done in Elm due to pseudo-elements \*/
    .auto-hide-scroll {
      overflow-y: auto;
    }
    .auto-hide-scroll::-webkit-scrollbar {
      width: 6px;
      height: 6px;
    }
    .auto-hide-scroll::-webkit-scrollbar-track {
      background: transparent;
    }
    .auto-hide-scroll::-webkit-scrollbar-thumb {
      background-color: rgba(128, 128, 128, 0.4);
      border-radius: 3px;
    }
     #main-content {
       overflow-y: auto;
       overflow-x: hidden !important;
     }
    #main-content::-webkit-scrollbar {
      width: 8px;
      height: 8px;
    }
    #main-content::-webkit-scrollbar-track {
      background: transparent;
    }
    #main-content::-webkit-scrollbar-thumb {
      background-color: rgba(128, 128, 128, 0.3);
      border-radius: 4px;
    }
    @media (min-width: 768px) {
      body .font-size-11 { font-size: 14px !important; }
      body .font-size-12 { font-size: 15px !important; }
      body .font-size-13 { font-size: 16px !important; }
      body .font-size-14 { font-size: 17px !important; }
      body .font-size-15 { font-size: 18px !important; }
      body .font-size-16 { font-size: 18px !important; }
      body .font-size-18 { font-size: 20px !important; }
      body .font-size-20 { font-size: 22px !important; }
       body .qh-favicon {
         display: inline-flex !important;
         align-items: center !important;
         justify-content: center !important;
         width: 18px !important;
         height: 18px !important;
         margin-right: 8px !important;
         vertical-align: middle !important;
       }
       [data-page="home"] .tab-link,
       [data-page="home"] .tab-link:hover,
       [data-page="home"] .tab-link:active,
       [data-page="home"] .tab-link:focus,
       [data-page="home"] button,
       [data-page="home"] button:hover,
       [data-page="home"] button:active,
       [data-page="home"] button:focus {
         box-shadow: none !important;
         text-shadow: none !important;
       }
       @keyframes qh-fade-in {
         from { opacity: 0; transform: translateY(8px); }
         to { opacity: 1; transform: translateY(0); }
       }
        @keyframes qh-fade-out {
         from { opacity: 1; transform: translateY(0); }
         to { opacity: 0; transform: translateY(-8px); }
       }
        @keyframes qh-insert {
          from { opacity: 0; transform: translateY(12px) scale(0.997); }
          60% { opacity: 1; transform: translateY(-2px) scale(1.001); }
          to { opacity: 1; transform: translateY(0) scale(1); }
        }
        /* Logo styles removed - now using inline styles */
          .qh-load-more {
           display: inline-flex;
           align-items: center;
           justify-content: center;
           background: #f1f5f9;
           color: #64748b;
           border-radius: 6px;
           padding: 4px 12px;
           border: none;
           box-shadow: none;
           transition: all 140ms ease;
           cursor: pointer;
           font-weight: 500;
           font-size: 12px;
           margin-top: 16px;
           width: auto;
           min-width: unset;
         }
         .qh-load-more:hover {
           background: #e2e8f0;
           color: #475569;
         }
         .qh-load-more:active {
           background: #cbd5e1;
         }
           .qh-load-more:focus {
             outline: none;
           }
           html[data-theme="dark"] .qh-load-more,
           html[data-theme="dark"] .qh-load-more span,
           html[data-theme="dark"] .qh-load-more button {
             background: #334155 !important;
             color: #f8fafc !important;
             border-color: #475569 !important;
           }
           html[data-theme="dark"] .qh-load-more:hover,
           html[data-theme="dark"] .qh-load-more:hover span,
           html[data-theme="dark"] .qh-load-more:hover button {
             background: #475569 !important;
             color: #fff !important;
           }
           html[data-theme="dark"] .qh-load-more:active,
           html[data-theme="dark"] .qh-load-more:active span,
           html[data-theme="dark"] .qh-load-more:active button {
             background: #1e293b !important;
           }
          .qh-notification {
          position: fixed !important;
          right: 12px !important;
          bottom: 12px !important;
          z-index: 1200 !important;
          background: rgba(17,24,39,0.9);
          color: #fff;
          padding: 6px 10px;
          border-radius: 999px;
          font-size: 12px;
          pointer-events: none;
          box-shadow: 0 6px 18px rgba(2,6,23,0.5);
        }
          /* Desktop site header styling */
          .qh-site-header { padding-left: 0; padding-right: 0; }
          @media (min-width: 640px) {
            .qh-site-header { padding-left: 24px; padding-right: 24px; }
          }

          /* Mobile-specific adjustments to prevent the site title from
             overlapping timeline content and to avoid the theme toggle
             clipping on narrow viewports. Targets both Elm-provided
             attribute selectors and common class names used for the brand
             and header actions. */
          @media (max-width: 640px) {
            .qh-site-header [data-brand],
            .qh-site-header .brand,
            .qh-site-header .site-brand {
              padding: 0 6px !important;
              line-height: 1 !important;
            }

            /* Ensure header actions (theme toggle, etc.) have a bit more
               right-side spacing so icons don't get clipped. */
            .qh-site-header .header-actions,
            .qh-site-header [data-header-actions] {
              padding-right: 8px !important;
            }
            /* Enforce padding on Elm-generated wrapper classes and direct
               anchor children so the brand spacing is always present. */
            .qh-site-header > a { padding: 0 6px !important; line-height: 1 !important; display: inline-flex; align-items: center; }
            .qh-site-header .pad-0-6-0-6 { padding: 0 6px !important; }
            .qh-site-header .pad-0-8-0-0 { padding: 0 8px 0 0 !important; }
          }
        </style>
      <script>
        // Removed aggressive color-extraction/enforcement JS to make Elm the
        // single source of truth for theme and colors. Keep small no-op
        // shims so other inline code that calls these functions won't fail.
        window.fixHeaderColors = window.fixHeaderColors || function() {};
        window.extractHeaderColors = window.extractHeaderColors || function() {};
        window.extractTimelineItemColors = window.extractTimelineItemColors || function() {};
        window.enforceReadableTimelineLinks = window.enforceReadableTimelineLinks || function() {};
      </script>
  </head>
  <body>
    <div id="app">
      <div style="display: flex; justify-content: center; align-items: center; height: 100vh; color: #111827; font-family: system-ui, sans-serif; font-size: 18px; background: #ffffff;">Loading QuickHeadlines...</div>
    </div>
    <script>document.write('<script src="/elm.js?v=' + Date.now() + '"><\/script>');</script>
  <script>
     // Header color cache with localStorage persistence (7-day expiration)
     window.feedHeaderCache = {};
     const HEADER_CACHE_KEY = 'qh_header_colors';
     const HEADER_CACHE_EXPIRY = 7 * 24 * 60 * 60 * 1000; // 7 days in milliseconds

     // Load cached colors from localStorage
     window.loadHeaderColorsFromCache = function() {
       try {
         const cached = localStorage.getItem(HEADER_CACHE_KEY);
         if (cached) {
           const parsed = JSON.parse(cached);
           const now = Date.now();
           // Filter out expired entries
           Object.keys(parsed).forEach(key => {
             const entry = parsed[key];
             if (entry.timestamp && (now - entry.timestamp) > HEADER_CACHE_EXPIRY) {
               delete parsed[key];
             }
           });
           // Save cleaned cache back
           localStorage.setItem(HEADER_CACHE_KEY, JSON.stringify(parsed));
           window.feedHeaderCache = parsed;
           return parsed;
         }
       } catch (e) {
         // localStorage unavailable or quota exceeded
       }
       return {};
     };

      // Apply cached colors immediately on page load
      window.applyCachedHeaderColors = function() {
        const cached = window.loadHeaderColorsFromCache();
        Object.keys(cached).forEach(key => {
          const entry = cached[key];
          // Find headers without server colors (data-use-server-colors is NOT set)
           const headers = document.querySelectorAll('.feed-header:not([data-use-server-colors="true"])');
          headers.forEach(header => {
            const img = header.querySelector('img');
              if (img && img.getAttribute('src') === key) {
               header.style.backgroundColor = entry.bg;
               header.style.color = entry.text;
               // Mark this element as JS-overridden so observers can remove the
               // inline styles when the user switches theme. This prevents stale
               // inline colors from persisting across theme changes.
               try { header.setAttribute('data-js-override', 'true'); } catch(e) {}
               const link = header.querySelector('a');
                if (link) {
                  // Avoid using !important from JS; use inline style which can be
                  // overridden by CSS. Also mark the link so it can be cleared on theme change.
                  link.style.color = entry.text;
                  try { link.setAttribute('data-js-override', 'true'); } catch(e) {}
                }
            }
          });
        });
      };

     // Save extracted colors to localStorage
     window.saveHeaderColorToCache = function(key, bg, text) {
       try {
         const cached = window.loadHeaderColorsFromCache();
         cached[key] = { bg: bg, text: text, timestamp: Date.now() };
         localStorage.setItem(HEADER_CACHE_KEY, JSON.stringify(cached));
         window.feedHeaderCache = cached;
       } catch (e) {
         // localStorage unavailable or quota exceeded
       }
      };

        // No-op placeholder: color extraction moved to Elm. Keep the function
        // so external calls are safe (older code or tests may still call it).
        window.extractHeaderColors = window.extractHeaderColors || function() {};

    (function() {
      var appElement = document.getElementById('app');
      if (!appElement) {
        console.error('app element not found');
        return;
      }

      var savedTheme = localStorage.getItem('quickheadlines-theme');
      var prefersDark = false;
      if (savedTheme) {
         prefersDark = savedTheme === 'dark';
       } else {
         prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
       }
       
         // Apply theme to document
         if (prefersDark) {
           document.documentElement.setAttribute('data-theme', 'dark');
         } else {
           document.documentElement.setAttribute('data-theme', 'light');
         }

         // Fix header colors for headers without server-provided text colors
         // Already scheduled via DOMContentLoaded above
      
       // Check if we should restore a previously saved page
        var savedPage = localStorage.getItem('quickheadlines-page');
        if (savedPage && savedPage !== window.location.pathname) {
          window.history.replaceState(null, '', savedPage);
        }

        // Get saved tab from localStorage
        var savedTab = localStorage.getItem('quickheadlines-tab');

          try {
              // Apply any cached header colors immediately so feed headers
              // render with readable colors before Elm finishes its first render.
              try { if (window.applyCachedHeaderColors) window.applyCachedHeaderColors(); } catch(e) {}

              var app = Elm.Main.init({
               node: appElement,
               flags: {
                width: window.innerWidth,
                height: window.innerHeight,
                prefersDark: prefersDark,
                timestamp: Date.now(),
                savedTab: savedTab
              }
            });
            window.app = app; // Expose for debugging

            if (app.ports && app.ports.saveTheme) {
              app.ports.saveTheme.subscribe(function(theme) {
                localStorage.setItem('quickheadlines-theme', theme);
                try {
                  // Keep the DOM in sync when Elm toggles theme so CSS that
                  // relies on `html[data-theme]` updates immediately.
                  document.documentElement.setAttribute('data-theme', theme);
                } catch(e) {}
                // Re-apply any cached header colors so they remain readable
                // after a theme change.
                try { if (window.applyCachedHeaderColors) window.applyCachedHeaderColors(); } catch(e) {}
              });
            }

             if (app.ports && app.ports.saveCurrentPage) {
               app.ports.saveCurrentPage.subscribe(function(page) {
                 localStorage.setItem('quickheadlines-page', page);
               });
             }

             if (app.ports && app.ports.saveActiveTab) {
               app.ports.saveActiveTab.subscribe(function(tab) {
                 localStorage.setItem('quickheadlines-tab', tab);
               });
             }

            window.addEventListener('resize', function() {
            // Handle resize if needed
          });

            // No aggressive JS color extraction/enforcement: re-apply cached
            // header colors as a lightweight optimization while Elm settles.
            setTimeout(function(){ try { window.applyCachedHeaderColors(); } catch(e) {} }, 500);
            setTimeout(function(){ try { window.applyCachedHeaderColors(); } catch(e) {} }, 1500);

            // Wait for timeline items to stabilize before doing a final enforcement pass.
            // Elm may re-render multiple times; instead of racing with timeouts, wait
            // until the number of timeline items has been stable for a short window
            // then run extraction and enforcement. This reduces the need to refresh.
            function waitForStableCount(selector, timeoutMs, stableWindowMs, cb) {
              const start = Date.now();
              let lastCount = -1;
              let stableSince = Date.now();
              (function check() {
                try {
                  const nodes = document.querySelectorAll(selector);
                  const count = nodes ? nodes.length : 0;
                  if (count === lastCount) {
                    if (Date.now() - stableSince >= stableWindowMs) return cb();
                  } else {
                    lastCount = count;
                    stableSince = Date.now();
                  }
                  if (Date.now() - start > timeoutMs) return cb();
                } catch (e) {
                  // ignore
                }
                setTimeout(check, 150);
              })();
            }

            // When timeline stabilizes, make a single pass to re-apply cached
            // header colors so feed headers look correct while Elm finishes.
            waitForStableCount('[data-timeline-item="true"]', 15000, 600, function() {
              try { window.applyCachedHeaderColors(); } catch(e) {}
            });

           // Watch for theme changes
              new MutationObserver(function(mutations) {
              mutations.forEach(function(mutation) {
                if (mutation.attributeName === 'data-theme') {
                  // On theme change, clear any JS overrides and re-apply cached header
                  // colors. Elm will take care of authoritative rendering.
                  try {
                    document.querySelectorAll('[data-js-override="true"]').forEach(function(el){
                      try { el.style.removeProperty('color'); } catch(e) {}
                      try { el.removeAttribute('data-js-override'); } catch(e) {}
                    });
                  } catch(e) {}
                  setTimeout(function() { try { window.applyCachedHeaderColors(); } catch(e) {} }, 50);
                  // Notify Elm about the theme change so Elm's model stays in sync
                  try {
                    var isDarkNow = document.documentElement.getAttribute('data-theme') === 'dark';
                    if (window.app && window.app.ports && window.app.ports.envThemeChanged) {
                      try { window.app.ports.envThemeChanged.send(isDarkNow); } catch(e) {}
                    }
                  } catch(e) {}
                }
              });
            }).observe(document.documentElement, { attributes: true });

          // Listen for OS theme changes and sync to Elm when no user preference is saved
          var themeMediaQuery = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)');
          if (themeMediaQuery) {
            themeMediaQuery.addEventListener('change', function(e) {
              var savedTheme = localStorage.getItem('quickheadlines-theme');
              if (savedTheme) {
                // User has explicitly set a theme; honor it and do not update
                return;
              }
              var isDark = e.matches;
              document.documentElement.setAttribute('data-theme', isDark ? 'dark' : 'light');
              if (app.ports && app.ports.envThemeChanged) {
                app.ports.envThemeChanged.send(isDark);
              }
            });
          }

          // Set up single MutationObserver for both color extraction and sentinel observation
          let sentinelObserver = null;
          let observerRetries = 0;
          const maxRetries = 50; // Retry for up to 5 seconds (50 * 100ms)
          
           const observeSentinel = () => {
             if (app.ports && app.ports.onNearBottom) {
               const sentinel = document.getElementById('scroll-sentinel');
                 if (sentinel && !sentinelObserver) {
                 // Try to find the nearest scrollable ancestor and use it as the observer root so
                 // the observer works when the sentinel is inside a scroll container (not the viewport).
                 function findScrollParent(el) {
                   var parent = el.parentElement;
                   while (parent) {
                     var style = window.getComputedStyle(parent);
                     var overflowY = (style.overflowY || '').toLowerCase();
                     // Only accept explicit scrolling containers
                     if (overflowY === 'auto' || overflowY === 'scroll' || overflowY === 'overlay') return parent;
                     parent = parent.parentElement;
                   }
                   return null;
                 }

                 // Prefer an actual scroll container. Only use the timeline page element as the root
                 // if it is explicitly scrollable; otherwise fall back to the viewport (null).
                 var potentialRoot = document.querySelector('[data-timeline-page="true"]');
                 var scrollRoot = findScrollParent(sentinel) || null;
                 if (!scrollRoot && potentialRoot) {
                   var potentialStyle = window.getComputedStyle(potentialRoot);
                   var potOverflow = (potentialStyle.overflowY || '').toLowerCase();
                   if (potOverflow === 'auto' || potOverflow === 'scroll' || potOverflow === 'overlay') {
                     scrollRoot = potentialRoot;
                   }
                 }

                 // Use rootMargin to trigger observer when element is within 500px of viewport/container bottom
                 // Only trigger near-bottom when sentinel is actually visible AND content is scrolled near bottom
                 sentinelObserver = new IntersectionObserver((entries) => {
                   entries.forEach(entry => {
                     // Only consider it "near bottom" if the sentinel is actually intersecting
                     // and the scroll position is near the bottom
                    if (entry.isIntersecting) {
                      // Use the inner scrollable container for scroll position
                      const scrollContainer = document.querySelector('#main-content > div');
                      if (scrollContainer) {
                        try {
                          const scrollTop = scrollContainer.scrollTop;
                          const scrollHeight = scrollContainer.scrollHeight;
                          const clientHeight = scrollContainer.clientHeight;
                           const maxScroll = scrollHeight - clientHeight;
                           const isScrolledNearBottom = maxScroll > 0 && scrollTop >= maxScroll - 600;

                           if (isScrolledNearBottom) {
                             try { app.ports.onNearBottom.send(true); } catch(e) { }
                           } else {
                           }
                         } catch(e) {
                         }
                       }
                     } else {
                       try { app.ports.onNearBottom.send(false); } catch(e) { }
                     }
                   });
                  }, { threshold: 0, root: null, rootMargin: '0px' });

                sentinelObserver.observe(sentinel);
                // Fallback: if IntersectionObserver doesn't report expected values in
                // some environments (nested scrollers, weird layout), also attach a
                // scroll/resize listener that computes sentinel position against the
                // chosen root and sends onNearBottom when within 500px of the bottom.
                (function() {
                  var lastSentinelState = null;
                  function checkSentinelVisibility() {
                    try {
                      if (!sentinel) return;
                      var rect = sentinel.getBoundingClientRect();
                      // Always use viewport for calculation
                       var near = rect.top <= (window.innerHeight + 500) && rect.bottom >= -500;

                       if (near !== lastSentinelState) {
                         lastSentinelState = near;
                         try { app.ports.onNearBottom.send(near); } catch(e) { }
                       }
                     } catch (e) {
                       // ignore measurement errors
                     }
                   }

                   // Poll for sentinel position changes
                   var pollingInterval = setInterval(function() {
                     checkSentinelVisibility();
                   }, 100);

                   // Also listen to scroll on scroll container if available
                   if (scrollRoot) {
                     scrollRoot.addEventListener('scroll', function() {
                       // Immediate check on scroll
                       checkSentinelVisibility();
                     }, { passive: true });
                   }
                   window.addEventListener('resize', checkSentinelVisibility);

                   // Run an initial check
                   setTimeout(checkSentinelVisibility, 50);
                 })();

                 observerRetries = 0;
               } else if (!sentinel && sentinelObserver) {
                 sentinelObserver.disconnect();
                 sentinelObserver = null;
               } else if (!sentinel && !sentinelObserver && observerRetries < maxRetries) {
                 observerRetries++;
                 setTimeout(observeSentinel, 100);
               }
             }
           };

          // Debounce function for mutations
          let mutationTimeout = null;
          const debouncedMutation = () => {
            if (mutationTimeout) clearTimeout(mutationTimeout);
            mutationTimeout = setTimeout(() => {
              window.extractHeaderColors();
              window.extractTimelineItemColors();
              observeSentinel();
            }, 300);
          };

         // Single mutation observer for both color extraction and sentinel
         const mutationObserver = new MutationObserver(debouncedMutation);
         mutationObserver.observe(document.body, { childList: true, subtree: true });

          // Try to observe sentinel immediately
          observeSentinel();


       } catch(e) {
         console.error('Elm init error:', e);
         appElement.innerHTML = '<p style="color: red;">Error: ' + e.message + '</p>';
       }
       
       // Add favicon fallback handling
       setTimeout(function() {
         document.querySelectorAll('img[src*="favicons"], img[alt*="favicon"], img[alt*="Feed favicon"]').forEach(function(img) {
           if (img.src && img.src !== '') {
             img.onerror = function() {
               // Try to extract domain from the image src or nearby text
               var src = img.getAttribute('src');
               var fallbackDomain = '';
               
               // Try to find a feed link nearby to extract domain
               var parent = img.closest('[data-feed-url]');
               if (parent) {
                 fallbackDomain = parent.getAttribute('data-feed-url');
               }
               
               if (!fallbackDomain && src) {
                 // Try to extract domain from current src
                 try {
                   var url = new URL(src);
                   fallbackDomain = url.hostname || '';
                 } catch (e) {}
               }
               
               // Use Google favicon service as fallback
               if (fallbackDomain) {
                 img.src = 'https://www.google.com/s2/favicons?domain=' + encodeURIComponent(fallbackDomain) + '&sz=64';
               } else {
                 // Last resort: use a generic favicon placeholder
                 img.src = 'data:image/svg+xml,%3Csvg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"%3E%3Ccircle cx="8" cy="8" r="7" fill="%23ccc"/%3E%3C/svg%3E';
               }
             };
           }
         });
       }, 500);
       
        // Also add mutation observer to handle dynamically added images
        var faviconObserver = new MutationObserver(function(mutations) {
          mutations.forEach(function(mutation) {
            if (mutation.addedNodes.length) {
              mutation.addedNodes.forEach(function(node) {
                if (node.nodeType === 1) { // Element node
                  var images = node.querySelectorAll ? node.querySelectorAll('img[src*="favicons"], img[alt*="favicon"], img[alt*="Feed favicon"]') : [];
                  images.forEach(function(img) {
                    if (img.onerror === null) {
                      img.onerror = arguments.callee;
                    }
                  });
                }
              });
            }
          });
        });

        faviconObserver.observe(appElement, { childList: true, subtree: true });

        // Final safety fix for any remaining headers
        setTimeout(fixHeaderColors, 5000);
       })();
      </script>
 </body>
</html>
